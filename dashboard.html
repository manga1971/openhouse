<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <title>Dashboard – Lum Vision</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body class="p-4">

  <header class="dashboard-header flex items-center justify-between mb-6">
    <h1 class="text-2xl font-extrabold">📊 Lum Vision – Dashboard</h1>
    <a href="vision-test.html" class="px-4 py-2 rounded transition">
      ← Înapoi la Test
    </a>
  </header>

  <section id="stats" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8">
    <div class="p-4 rounded shadow">
      <h2 class="text-sm font-medium">Total Teste</h2>
      <p id="total-tests" class="text-2xl font-bold">0</p>
    </div>
    <div class="p-4 rounded shadow">
      <h2 class="text-sm font-medium">Media Clipituri</h2>
      <p id="avg-blinks" class="text-2xl font-bold">–</p>
    </div>
    <div class="p-4 rounded shadow">
      <h2 class="text-sm font-medium">Ultimul Scor</h2>
      <p id="last-score" class="text-xl font-semibold">–</p>
    </div>
  </section>

  <section class="mb-8">
    <h2 class="text-lg font-bold mb-2">Grafic Clipituri (ultimele teste)</h2>
    <div id="graph" class="flex items-end space-x-1 h-40 p-4 rounded shadow overflow-x-auto"></div>
  </section>

  <section class="mb-8">
    <h2 class="text-lg font-bold mb-2">Jurnal Teste</h2>
    <ul id="history-list" class="space-y-2"></ul>
  </section>

  <section class="text-center">
    <button id="clear-history" class="px-4 py-2 text-white rounded hover:opacity-90 transition">
      Șterge Istoricul
    </button>
    <button id="export-csv" class="ml-3 px-4 py-2 text-white rounded hover:opacity-90 transition">
      Exportă CSV
    </button>
  </section>

  <div id="reminder-banner" class="fixed top-0 left-0 w-full p-3 text-center text-lg font-semibold shadow-lg z-50 hidden">
        E timpul să faci o pauză și să-ți odihnești ochii! 👀
        <button id="close-reminder" class="ml-4 text-white hover:text-gray-200 focus:outline-none">
            &times;
        </button>
    </div>

    <div class="fixed bottom-4 right-4 z-40">
        <button id="toggle-reminders-btn" class="px-4 py-2 rounded-full shadow-lg hover:opacity-90 transition">
            Memento-uri: <span id="reminder-status">Activ</span>
        </button>
    </div>

    <audio id="reminder-sound" preload="auto">
        <source src="https://cdn.pixabay.com/download/audio/2022/03/10/audio_24e030062f.mp3?filename=message-notification-112702.mp3" type="audio/mpeg">
    </audio>

<script>
  const totalTestsEl = document.getElementById("total-tests");
  const avgBlinksEl = document.getElementById("avg-blinks");
  const lastScoreEl = document.getElementById("last-score");
  const graphEl = document.getElementById("graph");
  const historyListEl = document.getElementById("history-list");
  const clearBtn = document.getElementById("clear-history");
  const exportCsvBtn = document.getElementById("export-csv");

  function loadHistory() {
    const history = JSON.parse(localStorage.getItem("lum_history") || "[]"); // Changed from vh_history

    totalTestsEl.textContent = history.length;

    if (history.length === 0) {
      avgBlinksEl.textContent = "–";
      lastScoreEl.textContent = "–";
      graphEl.innerHTML = "<p class='text-sm text-gray-500'>Nu există date.</p>";
      historyListEl.innerHTML = "<li class='text-sm text-gray-500 text-center'>Nicio înregistrare găsită.</li>";
      exportCsvBtn.classList.add("hidden");
      return;
    } else {
      exportCsvBtn.classList.remove("hidden");
    }

    // Calculul mediei clipiturilor pe minut, folosind 'blinks' și 'duration'
    const totalBlinks = history.reduce((sum, h) => sum + h.blinks, 0);
    const totalDuration = history.reduce((sum, h) => sum + (h.duration || 60), 0); // Folosește durata înregistrată sau un default de 60s
    const avgBlinksPerMinute = totalDuration > 0 ? ((totalBlinks / totalDuration) * 60).toFixed(1) : "0.0";
    avgBlinksEl.textContent = avgBlinksPerMinute;

    const last = history[history.length - 1];
    // Modifică aici pentru a reflecta feedback-ul bazat pe indiceLumina
    lastScoreEl.textContent = `${last.indiceLumina} – ${getEmojiFromIndice(last.indiceLumina)}`;

    graphEl.innerHTML = "";
    const recentHistory = history.slice(-10);
    // Pentru grafic, vom folosi indiceLumina pentru o reprezentare mai relevantă
    const maxIndice = Math.max(...recentHistory.map(entry => entry.indiceLumina), 1);

    recentHistory.forEach((entry) => {
      const height = (entry.indiceLumina / maxIndice) * 100;
      const bar = document.createElement("div");
      bar.className = `w-4 rounded-t flex-shrink-0 relative`;
      bar.style.height = `${height}%`;
      // Culorile barelor bazate pe Indice Lumina
      let barColorClass = "";
      if (entry.indiceLumina >= 80) { barColorClass = "bg-blue-500"; } // Radiant
      else if (entry.indiceLumina >= 60) { barColorClass = "bg-green-500"; } // Clear
      else if (entry.indiceLumina >= 40) { barColorClass = "bg-yellow-500"; } // Tired
      else { barColorClass = "bg-red-500"; } // Strained
      bar.classList.add(barColorClass);

      bar.title = `${entry.date}\nIndice Lumina: ${entry.indiceLumina}\nFeedback: ${entry.feedback}`;

      const label = document.createElement("span");
      label.textContent = entry.indiceLumina; // Afișează indicele de lumina
      label.className = "absolute bottom-full left-1/2 -translate-x-1/2 text-xs font-semibold text-gray-700";
      bar.appendChild(label);

      graphEl.appendChild(bar);
    });

    historyListEl.innerHTML = "";
    history.slice().reverse().forEach((entry) => {
      const li = document.createElement("li");
      li.className = "p-3 rounded shadow flex flex-col sm:flex-row items-start sm:items-center justify-between"; // Stilurile din style.css se aplică
      li.innerHTML = `
        <span class="text-sm mb-1 sm:mb-0">${entry.date}</span>
        <span class="text-lg font-semibold">${getEmojiFromIndice(entry.indiceLumina)} ${entry.indiceLumina} Indice Lumina <span class="text-base ml-2 hidden sm:inline">(${entry.feedback})</span></span>
        <span class="text-sm sm:hidden">${entry.feedback}</span>
      `;
      historyListEl.appendChild(li);
    });
  }

  // Funcție actualizată pentru a returna emoji-ul pe baza indicelui de lumină
  function getEmojiFromIndice(indice) {
    if (indice >= 80) return "✨";
    if (indice >= 60) return "😊";
    if (indice >= 40) return "😟";
    return "😩";
  }


  clearBtn.addEventListener("click", () => {
    if (confirm("Ești sigur că vrei să ștergi întregul istoric al testelor? Această acțiune este ireversibilă.")) {
      localStorage.removeItem("lum_history"); // Changed from vh_history
      loadHistory();
      alert("Istoricul a fost șters cu succes.");
    }
  });

  exportCsvBtn.addEventListener("click", () => {
    const history = JSON.parse(localStorage.getItem("lum_history") || "[]"); // Changed from vh_history
    if (history.length === 0) {
      alert("Nu există date de exportat.");
      return;
    }

    const header = "Data,IndiceLumina,Blinks,LuminosityScore,Feedback,Duration\n"; // Header actualizat
    const rows = history.map(h =>
      `"${h.date}",${h.indiceLumina},${h.blinks},${h.luminosityScore},"${h.feedback.replace(/"/g, '""')}",${h.duration || ''}` // Include și durata
    );
    const csvContent = header + rows.join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.setAttribute("href", url);
    link.setAttribute("download", "istoric_clipituri_Lum.csv"); // Changed filename
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  });

  window.addEventListener("DOMContentLoaded", loadHistory);

  // START: Memento-uri Inteligente pentru Relaxare Oculară
  const REMINDER_INTERVAL_HOURS = 3;
  const LAST_REMINDER_KEY = 'lum_last_reminder_timestamp'; // Changed from vh_last_reminder_timestamp
  const REMINDER_PREFERENCE_KEY = 'lum_reminders_enabled'; // Changed from vh_reminders_enabled

  const reminderBanner = document.getElementById('reminder-banner');
  const closeReminderBtn = document.getElementById('close-reminder');
  const toggleRemindersBtn = document.getElementById('toggle-reminders-btn');
  const reminderStatusSpan = document.getElementById('reminder-status');
  const reminderSound = document.getElementById('reminder-sound');

  let remindersEnabled = JSON.parse(localStorage.getItem(REMINDER_PREFERENCE_KEY) || 'true');

  function updateReminderStatusUI() {
      reminderStatusSpan.textContent = remindersEnabled ? 'Activ' : 'Inactiv';
      // Clasele de culori sunt acum în style.css, dar putem menține toggle-ul aici
      toggleRemindersBtn.classList.toggle('bg-purple-600', remindersEnabled); // Placeholder pentru culorile vechi, vor fi suprascrise de style.css
      toggleRemindersBtn.classList.toggle('bg-gray-500', !remindersEnabled);
  }

  function showReminder() {
      if (document.hidden) {
          return;
      }
      reminderBanner.classList.remove('hidden');
      reminderSound.play().catch(e => console.log("Eroare redare sunet memento:", e));
      localStorage.setItem(LAST_REMINDER_KEY, Date.now());
      setTimeout(() => {
          reminderBanner.classList.add('hidden');
      }, 8000);
  }

  function checkReminder() {
      if (!remindersEnabled) {
          return;
      }

      const lastReminderTimestamp = parseInt(localStorage.getItem(LAST_REMINDER_KEY) || '0');
      const currentTime = Date.now();
      const timeSinceLastReminder = currentTime - lastReminderTimestamp;
      const requiredIntervalMillis = REMINDER_INTERVAL_HOURS * 60 * 60 * 1000;

      if (timeSinceLastReminder >= requiredIntervalMillis) {
          showReminder();
      }
  }

  closeReminderBtn.addEventListener('click', () => {
      reminderBanner.classList.add('hidden');
      localStorage.setItem(LAST_REMINDER_KEY, Date.now());
  });

  toggleRemindersBtn.addEventListener('click', () => {
      remindersEnabled = !remindersEnabled;
      localStorage.setItem(REMINDER_PREFERENCE_KEY, JSON.stringify(remindersEnabled));
      updateReminderStatusUI();
      if (remindersEnabled) {
          checkReminder();
      }
  });

  function resetReminderTimer() {
      localStorage.setItem(LAST_REMINDER_KEY, Date.now());
  }

  updateReminderStatusUI();
  setInterval(checkReminder, 60 * 1000);
  setTimeout(checkReminder, 1000);
  // END: Memento-uri Inteligente pentru Relaxare Oculară
</script>

</body>
</html>
