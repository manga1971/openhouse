<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forma - Home (Dictare)</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval@6/dist/umd.js"></script>
    <script src="common.js"></script>
</head>
<body>

    <div class="app-container">
        <header class="app-header">
            <h1 class="app-title">Forma</h1>
            <button id="accountSettingsButton" class="icon-button">
                <svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
            </button>
        </header>

        <div id="mainDictationArea" class="glass-container dictation-main-area">
            <h2 class="section-title" id="formContextTitle">New Form</h2>
            
            <div id="dictationStatusArea" class="dictation-status-box">
                <div id="visualWave" class="wave-indicator"></div>
                <p id="dictationStatusText">Press "Dictate" button below to start speaking...</p>
            </div>

            <div id="transcriptionText" class="text-display custom-scrollbar">
                Your dictated text will appear here.
            </div>
            
            <div class="button-group-row">
                <button id="saveDictatedTextButton" class="button-secondary">Save</button>
                <button id="editDictatedTextButton" class="button-primary">Edit</button>
                <button id="deleteDictatedTextButton" class="button-danger">Delete</button>
            </div>
        </div>

        <nav class="main-navbar">
            <div class="navbar-group">
                <a href="index.html" class="navbar-button active">
                    <svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 15H9V7h2v10zm4 0h-2V7h2v10z"/></svg>
                    <span>New Form</span>
                </a>
                <a href="my-forms.html" class="navbar-button">
                    <svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 11H5m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 7v7m0-7H5m14 0v7m0-7H5m7 0v7"/></svg>
                    <span>My Forms</span>
                </a>
            </div>
            <button class="navbar-search-button" onclick="alert('Search functionality to be implemented in My Forms and Form Report pages.')">
                <svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0016 9.5 6.5 6.5 0 109.5 16a6.471 6.471 0 003.73-1.29l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
            </button>
        </nav>

    </div>

    <button id="dictateToggleButton" class="fixed-dictate-button">
        <svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="dictateIcon"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 4c0-1.66-1.34-3-3-3S9 2.34 9 4v7c0 1.66 1.34 3 3 3zm5.3-3c0 3.53-2.64 6.43-6.14 6.95V21h-2v-3.05c-3.5-.52-6.16-3.42-6.16-6.95H2c0 4.17 3.13 7.63 7.27 8.24v3.01h5.46v-3.01c4.14-.61 7.27-4.07 7.27-8.24h-1.7z"/></svg>
        Dictate
    </button>

    <script>
        // DOM Elements
        const formContextTitle = document.getElementById('formContextTitle');
        const dictationStatusArea = document.getElementById('dictationStatusArea');
        const visualWave = document.getElementById('visualWave');
        const dictationStatusText = document.getElementById('dictationStatusText');
        const transcriptionText = document.getElementById('transcriptionText');

        const saveDictatedTextButton = document.getElementById('saveDictatedTextButton'); 
        const editDictatedTextButton = document.getElementById('editDictatedTextButton'); // Renamed
        const deleteDictatedTextButton = document.getElementById('deleteDictatedTextButton'); // Renamed

        const dictateToggleButton = document.getElementById('dictateToggleButton');
        const dictateIcon = document.getElementById('dictateIcon'); // Reference to the icon inside the button

        const accountSettingsButton = document.getElementById('accountSettingsButton');


        // Global State Variables
        let currentFormId = null; 
        let isDictating = false; 
        let simulatedDictatedText = ""; 
        let currentSegmentId = null; // To track the ID of the segment being dictated (if saved)

        // --- UI & Dictation Logic ---

        function updateDictationButton(isActivelyDictating) {
            if (isActivelyDictating) {
                dictateToggleButton.textContent = 'Stop';
                dictateToggleButton.classList.add('active-dictation-button'); // Add a class for potential styling
                dictateIcon.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>'; // Pause icon
            } else {
                dictateToggleButton.textContent = 'Dictate';
                dictateToggleButton.classList.remove('active-dictation-button');
                dictateIcon.innerHTML = '<path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 4c0-1.66-1.34-3-3-3S9 2.34 9 4v7c0 1.66 1.34 3 3 3zm5.3-3c0 3.53-2.64 6.43-6.14 6.95V21h-2v-3.05c-3.5-.52-6.16-3.42-6.16-6.95H2c0 4.17 3.13 7.63 7.27 8.24v3.01h5.46v-3.01c4.14-.61 7.27-4.07 7.27-8.24h-1.7z"/>'; // Mic icon
            }
        }

        function startNativeDictationProcess() {
            if (isDictating) return;

            isDictating = true;
            dictationStatusText.textContent = 'Listening... Speak clearly.';
            visualWave.classList.add('active');
            visualWave.style.opacity = '1';
            updateDictationButton(true);
            
            transcriptionText.textContent = ''; 
            simulatedDictatedText = "";
            saveDictatedTextButton.disabled = true;
            editDictatedTextButton.disabled = true;
            deleteDictatedTextButton.disabled = true;

            let textSegments = [
                "Acesta este primul segment al dictării mele. ",
                "Vreau să adaug un task nou, și anume: să verific stocul la depozit până vineri. ",
                "Am vorbit și despre proiectul X și este important să planificăm o întâlnire săptămâna viitoare. ",
                "Acest segment se încheie aici și este gata de procesare."
            ];
            let segmentIndex = 0;
            let charIndex = 0;

            window.dictationTypingInterval = setInterval(() => {
                if (!isDictating) {
                    clearInterval(window.dictationTypingInterval);
                    return;
                }
                if (segmentIndex < textSegments.length) {
                    if (charIndex < textSegments[segmentIndex].length) {
                        simulatedDictatedText += textSegments[segmentIndex][charIndex];
                        transcriptionText.textContent = simulatedDictatedText;
                        transcriptionText.scrollTop = transcriptionText.scrollHeight;
                        charIndex++;
                    } else {
                        segmentIndex++;
                        charIndex = 0;
                    }
                } else {
                    clearInterval(window.dictationTypingInterval);
                    stopNativeDictationProcess(true);
                }
            }, 50);
        }

        function stopNativeDictationProcess(dictationSuccessful = false) {
            if (!isDictating) return;

            isDictating = false;
            clearInterval(window.dictationTypingInterval);
            
            dictationStatusText.textContent = dictationSuccessful ? 'Dictation complete. Review and save.' : 'Dictation stopped. No text saved.';
            visualWave.classList.remove('active');
            visualWave.style.opacity = '0';
            updateDictationButton(false);

            if (dictationSuccessful && simulatedDictatedText.trim().length > 0) {
                saveDictatedTextButton.disabled = false;
                editDictatedTextButton.disabled = false; // Enable Edit button as it also saves
                deleteDictatedTextButton.disabled = false;
            } else {
                saveDictatedTextButton.disabled = true;
                editDictatedTextButton.disabled = true;
                deleteDictatedTextButton.disabled = true;
            }
        }

        // --- Form Data Save & Management ---

        async function createOrUpdateFormMetadata(formToUpdate = null) {
            let formData;
            let allForms = (await db.get('formsMetadata')) || [];

            if (formToUpdate) { // Updating an existing form
                currentFormId = formToUpdate.id;
                formData = { ...formToUpdate }; // Copy existing data
                // Update specific fields that might change if user later decides to fill them
                formData.title = formToUpdate.title || `Quick Note - ${new Date(formToUpdate.createdAt).toLocaleDateString('en-US')} ${new Date(formToUpdate.createdAt).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit'})}`;
                formData.lastModified = new Date().toISOString();
            } else if (currentFormId) { // Editing an existing form loaded by ID from URL
                formData = allForms.find(f => f.id === currentFormId);
                if (!formData) { // Should not happen if loadFormDataAndHistory is correct
                    console.error("Attempted to update a form not found with currentFormId.");
                    // Fallback to creating new if somehow ID is set but form not found
                    return createOrUpdateFormMetadata(null); 
                }
                formData.lastModified = new Date().toISOString();
            } else { // Creating a brand new form (e.g., first dictation on a fresh app load)
                let lastFormSequenceNumber = (await db.get('lastFormSequenceNumber')) || 0;
                const newFormNumber = ++lastFormSequenceNumber;
                currentFormId = generateUUID(); 
                await db.set('lastFormSequenceNumber', newFormNumber);

                const now = new Date();
                now.setMinutes(now.getMinutes() - now.getTimezoneOffset()); 
                const quickFormTitle = `Quick Note - ${now.toLocaleDateString('en-US')} ${now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit'})}`;

                formData = {
                    id: currentFormId,
                    formNumber: newFormNumber,
                    title: quickFormTitle,
                    beneficiary: '',
                    type: 'other', 
                    plannedDateTime: now.toISOString(),
                    address: '',
                    initialNotes: '',
                    status: 'not-started', // Initially not-started
                    createdAt: now.toISOString(),
                    lastModified: now.toISOString()
                };
            }

            // Update form status to "in-progress" if a dictation is added/edited for it
            if (formData.status === 'not-started') {
                formData.status = 'in-progress';
            }

            const index = allForms.findIndex(f => f.id === currentFormId);
            if (index !== -1) {
                allForms[index] = formData;
            } else {
                allForms.unshift(formData); // Add new form to top
            }
            
            await db.set('formsMetadata', allForms);
            formContextTitle.textContent = `Form #${formData.formNumber || 'N/A'}`; // Update title
            return formData; 
        }

        // Save a dictated text segment
        async function saveDictatedSegment(text) {
            // Ensure a form exists and is the context for this dictation
            let form = await createOrUpdateFormMetadata(null); // Ensures currentFormId is set and form exists
            currentFormId = form.id; // Confirm currentFormId is the one we're saving to

            if (!text || text.trim().length === 0) {
                alert('Cannot save an empty note.');
                return null;
            }

            const now = new Date();
            currentSegmentId = generateUUID(); // Assign ID to current segment

            const segmentMetaData = {
                id: currentSegmentId,
                formId: currentFormId,
                name: `Note ${now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`, // Simplified name
                status: 'draft', 
                recordedAtTime: now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
                recordedAtDate: now.toLocaleDateString('en-US'),
                duration: Math.ceil(text.trim().split(/\s+/).length / 2.5), 
                text: text.trim(), 
                tasks: [] // Tasks will be extracted manually later
            };

            const formRecordings = (await db.get(`formRecordings-${currentFormId}`)) || [];
            formRecordings.unshift(segmentMetaData); // Add new segment to the top
            await db.set(`formRecordings-${currentFormId}`, formRecordings);
            
            alert('Dictated note saved successfully!');
            return segmentMetaData;
        }

        // --- Event Listeners ---

        dictateToggleButton.addEventListener('click', async () => {
            if (isDictating) {
                stopNativeDictationProcess(true);
            } else {
                // Ensure form context is established before dictating
                await createOrUpdateFormMetadata(null); // This will set currentFormId if new, or ensure it's loaded
                startNativeDictationProcess();
            }
        });

        saveDictatedTextButton.addEventListener('click', async () => {
            if (simulatedDictatedText) {
                const savedSegment = await saveDictatedSegment(simulatedDictatedText);
                if (savedSegment) {
                    // After saving, reset UI for next dictation or allow new actions
                    stopNativeDictationProcess(false); // Reset to non-dictating state
                    transcriptionText.textContent = ''; 
                    simulatedDictatedText = ''; 
                    // No need to disable edit/delete here, as save button handles its own state
                }
            } else {
                alert("Nothing to save. Dictate something first!");
            }
        });

        editDictatedTextButton.addEventListener('click', async () => {
            if (simulatedDictatedText) {
                const savedSegment = await saveDictatedSegment(simulatedDictatedText); // Save first
                if (savedSegment) {
                    // Reset UI for dictation
                    stopNativeDictationProcess(false); 
                    transcriptionText.textContent = '';
                    simulatedDictatedText = '';
                    // Redirect to form-report.html to edit/extract tasks for the form/segment
                    window.location.href = `form-report.html?id=${currentFormId}`; 
                }
            } else if (currentFormId) {
                 // If no current dictation, but a form is active, go to its report
                window.location.href = `form-report.html?id=${currentFormId}`; 
            } else {
                alert("Nothing to edit. Dictate something first or load an existing form.");
            }
        });

        deleteDictatedTextButton.addEventListener('click', () => {
            if (confirm('Are you sure you want to discard this dictated note? It will not be saved.')) {
                transcriptionText.textContent = '';
                simulatedDictatedText = '';
                alert('Dictated note discarded.');
            }
            stopNativeDictationProcess(false);
            transcriptionText.textContent = '';
            simulatedDictatedText = ''; 
        });

        accountSettingsButton.addEventListener('click', () => {
            alert('Account settings functionality to be implemented.');
        });


        // --- Page Load & Initialization ---

        async function loadInitialFormData() {
            const params = new URLSearchParams(window.location.search);
            const formIdFromURL = params.get('id'); 

            if (formIdFromURL) {
                const allForms = (await db.get('formsMetadata')) || [];
                const formToLoad = allForms.find(f => f.id === formIdFromURL);

                if (formToLoad) {
                    currentFormId = formIdFromURL;
                    formContextTitle.textContent = `Form #${formToLoad.formNumber || 'N/A'}`; // Update context title
                    
                    // Pre-fill form details if they exist for editing
                    // (This part is visually hidden but data could be loaded for consistency)
                    if (document.getElementById('formTitleInput')) { // Check if elements exist (they're not visible but JS might reference)
                        document.getElementById('formTitleInput').value = formToLoad.title || '';
                        document.getElementById('formBeneficiaryInput').value = formToLoad.beneficiary || '';
                        document.getElementById('formTypeSelect').value = formToLoad.type || 'other';
                        if (formToLoad.plannedDateTime) {
                            document.getElementById('formPlannedDateInput').value = new Date(formToLoad.plannedDateTime).toISOString().slice(0, 16);
                        } else {
                            const now = new Date();
                            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
                            document.getElementById('formPlannedDateInput').value = now.toISOString().slice(0, 16);
                        }
                        document.getElementById('formAddressInput').value = formToLoad.address || '';
                        document.getElementById('formInitialNotesInput').value = formToLoad.initialNotes || '';
                    }

                    // Load last 1-2 segments for continuation
                    const formRecordings = (await db.get(`formRecordings-${currentFormId}`)) || [];
                    if (formRecordings.length > 0) {
                        formRecordings.sort((a, b) => new Date(b.recordedAtDate + ' ' + b.recordedAtTime).getTime() - new Date(a.recordedAtDate + ' ' + a.recordedAtTime).getTime());
                        const lastSegmentsText = formRecordings.slice(0, 2).map(rec => rec.text).reverse().join('\n\n');
                        transcriptionText.textContent = `...${lastSegmentsText}\n\n`;
                        transcriptionText.scrollTop = transcriptionText.scrollHeight; 
                        dictationStatusText.textContent = `Continuing dictation for Form #${formToLoad.formNumber || 'N/A'}. Press "Dictate" to add more...`;
                    } else {
                        dictationStatusText.textContent = `Start dictating for Form #${formToLoad.formNumber || 'N/A'}. Press "Dictate" below...`;
                    }
                } else {
                    // Form ID not found, start fresh
                    alert('Form not found. Starting a new blank form.');
                    currentFormId = null;
                    window.history.replaceState(null, null, 'index.html'); // Clean URL
                    formContextTitle.textContent = 'New Form';
                    dictationStatusText.textContent = 'Press "Dictate" button below to start speaking for a new form...';
                }
            } else {
                // No form ID in URL, fresh start
                formContextTitle.textContent = 'New Form';
                dictationStatusText.textContent = 'Press "Dictate" button below to start speaking for a new form...';
            }
            // Ensure buttons are disabled initially
            saveDictatedTextButton.disabled = true;
            editDictatedTextButton.disabled = true;
            deleteDictatedTextButton.disabled = true;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await loadInitialFormData(); 
            stopNativeDictationProcess(false); 
        });
    </script>
</body>
</html>
