<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forma - Home / New & Edit Form</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval@6/dist/umd.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c, #2d3748);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 2rem;
            padding-bottom: 7rem; /* Increased padding for fixed button */
        }
        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .status-indicator {
            width: 8px;
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
        }
        /* Adjusted status colors for better UX, as discussed */
        .status-green { background-color: #22c55e; }   /* Completed */
        .status-red { background-color: #ef4444; }     /* Failed / Error */
        .status-yellow { background-color: #f59e0b; }  /* In Progress / Draft */
        .status-gray { background-color: #6b7280; }    /* Not Started */

        /* Custom scrollbar */
        .scrollable-list::-webkit-scrollbar {
            width: 8px;
        }
        .scrollable-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .scrollable-list::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        .scrollable-list::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Input field text color (CRITICAL FIX) */
        input[type="text"],
        input[type="datetime-local"],
        select,
        textarea {
            color: #ffffff; /* White text for input fields */
            background-color: #4a5568; /* Tailwind gray-700 equivalent */
            border-color: #4a5568; /* Tailwind gray-600 equivalent */
        }
        input::placeholder,
        textarea::placeholder {
            color: rgba(255, 255, 255, 0.6); /* Lighter placeholder for contrast */
        }

        /* Accordion styles */
        .accordion-header {
            background: rgba(255, 255, 255, 0.15);
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }
        .accordion-content {
            padding: 1rem;
            border-radius: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            margin-top: -0.5rem; 
            margin-bottom: 1rem;
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }
        .accordion-icon {
            transition: transform 0.2s;
        }
        .accordion-header.collapsed .accordion-icon {
            transform: rotate(-90deg);
        }

        /* Small status indicators for recordings list (not dots for F1) */
        .recording-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }
        .dot-confirmed { background-color: #4CAF50; }
        .dot-failed { background-color: #F44336; }
        .dot-draft { background-color: #FFC107; }

        /* Navbar Custom Style */
        .custom-navbar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 0.5rem; 
            border-radius: 9999px; 
            width: fit-content; 
            margin: 0 auto; 
            display: flex;
            justify-content: center; 
            align-items: center;
            gap: 0.5rem; 
        }
        .custom-navbar .nav-group {
            display: flex;
            background: rgba(255, 255, 255, 0.1); 
            border-radius: 9999px; 
            overflow: hidden; 
        }
        .custom-navbar .nav-group a,
        .custom-navbar .nav-group button {
            padding: 0.75rem 1rem; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #cbd5e1; 
            transition: background-color 0.2s, color 0.2s;
            text-decoration: none;
            flex-shrink: 0;
            min-width: 60px;
            border-radius: 9999px; 
        }
        .custom-navbar .nav-group a:hover,
        .custom-navbar .nav-group button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        /* Active Navbar Button Style - Rounded Background */
        .custom-navbar .nav-group a.active,
        .custom-navbar .nav-group button.active {
            background-color: #6366f1; 
            color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); 
            padding-left: 1.25rem; 
            padding-right: 1.25rem;
            margin: 0 2px; 
        }
        .custom-navbar .search-btn {
            background-color: #6366f1; 
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            transition: background-color 0.2s, color 0.2s;
            flex-shrink: 0;
            margin-left: 0.5rem; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); 
        }
        .custom-navbar .search-btn:hover {
            background-color: #5a5ee0; 
            color: #fff;
        }
        .custom-navbar .search-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Post-Recording Action Buttons Style */
        .post-record-action-button {
            width: 100%;
            font-bold py-3 px-4 rounded-lg transition duration-300 text-lg;
        }
        .post-record-action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* New Dictation Interface Styles */
        #dictationStatusArea {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 1.5rem;
            padding: 1rem 1.5rem;
            width: 95%;
            max-width: 350px;
            margin: 0 auto;
            box-sizing: border-box;
            min-height: 100px; /* Ensure visibility */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #visualWave {
            width: 80%; /* Adjust width for better visual */
            height: 8px; /* Thicker wave */
            background-color: #a78bfa; /* Purple color for wave */
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #visualWave.active {
            animation: wave-animation 1.5s infinite alternate;
        }
        @keyframes wave-animation {
            0%, 100% { transform: scaleX(0.2); opacity: 0.5; }
            50% { transform: scaleX(1); opacity: 1; }
        }

        /* Fixed Dictate/Stop Button */
        .fixed-dictate-button {
            position: fixed;
            bottom: 1.5rem; /* Adjust as needed */
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background-color: #6366f1;
            color: white;
            font-weight: bold;
            padding: 1rem 2rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 1.25rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s, transform 0.2s;
        }
        .fixed-dictate-button:hover {
            background-color: #5a5ee0;
            transform: translateX(-50%) scale(1.03);
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="relative w-full max-w-md mx-auto p-4 pb-20"> 
        <header class="text-center mb-6 flex justify-between items-center">
            <h1 class="text-3xl font-extrabold text-white flex-grow text-center">Forma</h1>
            <button id="accountButton" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center">
                <svg class="w-5 h-5 mr-1" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                Account
            </button>
        </header>

        <div id="formDetailsAccordion" class="glass rounded-xl shadow-lg mb-8">
            <div class="accordion-header" onclick="toggleAccordion('formDetailsContent', this)">
                <span>Characteristics / Details</span>
                <svg class="w-5 h-5 accordion-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="formDetailsContent" class="accordion-content">
                <form id="formCreationForm">
                    <div class="mb-4">
                        <label for="formTitleInput" class="block text-indigo-200 text-sm font-bold mb-2">Objective Title:</label>
                        <input type="text" id="formTitleInput" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline" placeholder="e.g., Villa Dacia No 75 Inspection" required>
                    </div>
                    <div class="mb-4">
                        <label for="formBeneficiaryInput" class="block text-indigo-200 text-sm font-bold mb-2">Client:</label>
                        <input type="text" id="formBeneficiaryInput" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline" placeholder="e.g., Colosseum SRL">
                    </div>
                    <div class="mb-4 hidden"> 
                        <label for="formTypeSelect" class="block text-indigo-200 text-sm font-bold mb-2">Form Type:</label>
                        <select id="formTypeSelect" class="shadow border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                            <option value="inspection">Inspection</option>
                            <option value="estimation">Estimation</option>
                            <option value="reception">Reception</option>
                            <option value="meeting">Meeting</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="formPlannedDateInput" class="block text-indigo-200 text-sm font-bold mb-2">Planned Date & Time:</label>
                        <input type="datetime-local" id="formPlannedDateInput" class="shadow border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                    <div class="mb-4">
                        <label for="formAddressInput" class="block text-indigo-200 text-sm font-bold mb-2">Address:</label>
                        <input type="text" id="formAddressInput" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline" placeholder="e.g., Blvd Dacia No 75">
                    </div>
                    
                    <div class="mt-6 mb-4">
                        <h3 class="text-xl font-semibold text-indigo-200 mb-2">Personal Notes:</h3>
                        <textarea id="formInitialNotesInput" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline h-24" placeholder="Any preliminary details or aspects..."></textarea>
                    </div>

                    <button type="button" id="saveFormDetailsButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 text-lg">
                        Save Form Details
                    </button>
                </form>
            </div>
        </div>

        <div id="liveTranscriptionSection" class="glass p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold mb-3">Add Voice Note</h2>
            
            <div id="dictationStatusArea" class="flex flex-col items-center justify-center bg-gray-800 rounded-lg p-4 mb-4">
                <div id="visualWave" class="w-full h-2 rounded-full bg-indigo-500 opacity-0 transition-opacity duration-300 mb-2"></div>
                <p id="dictationStatusText" class="text-indigo-300">Press "Dictate" button below to start speaking...</p>
            </div>

            <div id="transcriptionText" class="text-indigo-100 text-left min-h-[100px] max-h-[200px] overflow-y-auto border border-gray-600 rounded p-3 bg-gray-800 mb-4">
                Your dictated text will appear here.
            </div>
            
            <div class="mt-4 flex flex-col gap-3 mx-auto max-w-xs">
                <button id="saveDictatedTextButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 text-lg" disabled>
                    Save Dictated Note
                </button>
                <button id="discardDictatedTextButton" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 text-lg" disabled>
                    Discard Note
                </button>
                <button id="viewTranscriptReportButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 text-lg" disabled>
                    View Full Form Report
                </button>
            </div>
        </div>

        <div class="glass p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold mb-4">Recording History for this Form</h2>
            <div id="formRecordingsList" class="flex flex-col gap-4 max-h-96 overflow-y-auto scrollable-list">
                <p class="text-indigo-200 text-center" id="noRecordingsMessage">No dictated notes yet for this form.</p>
            </div>
        </div>
        
        <nav class="fixed bottom-0 left-0 right-0 custom-navbar z-10">
            <div class="nav-group">
                <a href="new-form.html" class="active">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                    <span class="text-xs mt-1">Home</span>
                </a>
                <a href="index.html" class="">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 11H5m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 7v7m0-7H5m14 0v7m0-7H5m7 0v7"/></svg>
                    <span class="text-xs mt-1">My Forms</span>
                </a>
            </div>
            <button class="search-btn" onclick="alert('Search functionality to be implemented.')">
                <svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0016 9.5 6.5 6.5 0 109.5 16a6.471 6.471 0 003.73-1.29l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
            </button>
        </nav>

    </div>

    <button id="dictateToggleButton" class="fixed-dictate-button">
        Dictate
    </button>

    <script>
        // Form fields and related elements
        const pageTitle = document.getElementById('pageTitle'); // This will be removed from header, using generic "Forma"
        const formCreationForm = document.getElementById('formCreationForm');
        const formTitleInput = document.getElementById('formTitleInput');
        const formBeneficiaryInput = document.getElementById('formBeneficiaryInput');
        const formTypeSelect = document.getElementById('formTypeSelect'); 
        const formPlannedDateInput = document.getElementById('formPlannedDateInput');
        const formAddressInput = document.getElementById('formAddressInput');
        const formInitialNotesInput = document.getElementById('formInitialNotesInput'); // Now inside characteristics
        const saveFormDetailsButton = document.getElementById('saveFormDetailsButton'); 
        
        // Accordion elements
        const formDetailsAccordion = document.getElementById('formDetailsAccordion'); 
        const formDetailsContent = document.getElementById('formDetailsContent');

        // New Dictation interface elements
        const dictationStatusArea = document.getElementById('dictationStatusArea');
        const visualWave = document.getElementById('visualWave');
        const dictationStatusText = document.getElementById('dictationStatusText');
        const transcriptionText = document.getElementById('transcriptionText');

        // Post-dictation action buttons
        const saveDictatedTextButton = document.getElementById('saveDictatedTextButton'); 
        const discardDictatedTextButton = document.getElementById('discardDictatedTextButton'); 
        const viewTranscriptReportButton = document.getElementById('viewTranscriptReportButton'); 

        // Dictate/Stop Button (Fixed)
        const dictateToggleButton = document.getElementById('dictateToggleButton');

        // Notes History list
        const formRecordingsListContainer = document.getElementById('formRecordingsList');
        const noRecordingsMessage = document.getElementById('noRecordingsMessage');

        let currentFormId = null; 
        let isDictating = false; // Tracks if dictation is active
        let simulatedDictatedText = ""; // Accumulates simulated dictated text

        // --- UI & Accordion Logic ---

        function toggleAccordion(contentId, headerElement, forceCollapse = false) {
            const content = document.getElementById(contentId);
            const icon = headerElement.querySelector('.accordion-icon');

            if (forceCollapse) {
                if (content.style.display !== 'none') { 
                    content.style.display = 'none';
                    icon.style.transform = 'rotate(-90deg)';
                    headerElement.classList.add('collapsed');
                }
            } else { 
                if (content.style.display === 'none' || content.style.display === '') {
                    content.style.display = 'block';
                    icon.style.transform = 'rotate(0deg)';
                    headerElement.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    icon.style.transform = 'rotate(-90deg)';
                    headerElement.classList.add('collapsed');
                }
            }
        }

        // Setup accordions based on if it's a new form or editing an existing one
        function setupAccordions(isEditing = false) {
            // For new forms, Characteristics/Details is open by default
            formDetailsContent.style.display = 'block';
            document.querySelector('#formDetailsAccordion .accordion-header').classList.remove('collapsed');
        }

        // --- Dictation Interface Functions (Simulated) ---

        function startNativeDictationProcess() {
            if (isDictating) return; // Prevent multiple starts

            isDictating = true;
            dictationStatusText.textContent = 'Listening... Speak clearly.';
            visualWave.classList.add('active');
            visualWave.style.opacity = '1';
            dictateToggleButton.textContent = 'Stop';
            
            transcriptionText.textContent = ''; // Clear previous text
            simulatedDictatedText = "";
            saveDictatedTextButton.disabled = true;
            discardDictatedTextButton.disabled = true;

            // Simulate dictation input from OS
            let textSegments = [
                "Acesta este primul segment al dictării mele. ",
                "Vreau să adaug un task nou, și anume: să verific stocul la depozit până vineri. ",
                "Am vorbit și despre proiectul X și este important să planificăm o întâlnire săptămâna viitoare. ",
                "Acest segment se încheie aici și este gata de procesare."
            ];
            let segmentIndex = 0;
            let charIndex = 0;

            window.dictationTypingInterval = setInterval(() => {
                if (!isDictating) { // Check if dictation was stopped externally
                    clearInterval(window.dictationTypingInterval);
                    return;
                }
                if (segmentIndex < textSegments.length) {
                    if (charIndex < textSegments[segmentIndex].length) {
                        simulatedDictatedText += textSegments[segmentIndex][charIndex];
                        transcriptionText.textContent = simulatedDictatedText;
                        transcriptionText.scrollTop = transcriptionText.scrollHeight; // Scroll to bottom
                        charIndex++;
                    } else {
                        segmentIndex++;
                        charIndex = 0;
                    }
                } else {
                    // Dictation finished naturally
                    clearInterval(window.dictationTypingInterval);
                    stopNativeDictationProcess(true);
                }
            }, 50); // Simulate typing speed
            
            // Collapse accordion when dictation starts
            toggleAccordion('formDetailsContent', document.querySelector('#formDetailsAccordion .accordion-header'), true);
        }

        function stopNativeDictationProcess(dictationSuccessful = false) {
            if (!isDictating) return; // Only stop if currently dictating

            isDictating = false;
            clearInterval(window.dictationTypingInterval); // Stop simulated typing
            
            dictationStatusText.textContent = dictationSuccessful ? 'Dictation complete. Review and save.' : 'Dictation stopped. No text saved.';
            visualWave.classList.remove('active');
            visualWave.style.opacity = '0';
            dictateToggleButton.textContent = 'Dictate';

            if (dictationSuccessful && simulatedDictatedText.trim().length > 0) {
                saveDictatedTextButton.disabled = false;
                discardDictatedTextButton.disabled = false;
                viewTranscriptReportButton.disabled = false; // Always enable if form has recordings
            } else {
                saveDictatedTextButton.disabled = true;
                discardDictatedTextButton.disabled = true;
            }
        }

        // --- Form Data Save & Status Management ---

        async function saveFormData(newStatus = null) {
            const selectedSections = []; // No longer used for F1

            // If no formId exists, create a new temporary one if user starts dictating without saving details
            if (!currentFormId) {
                let lastFormSequenceNumber = (await idbKeyval.get('lastFormSequenceNumber')) || 0;
                const newFormNumber = ++lastFormSequenceNumber;
                currentFormId = crypto.randomUUID(); // Assign new ID here
                await idbKeyval.set('lastFormSequenceNumber', lastFormSequenceNumber);

                // Initialize basic form data for a quick dictation
                const now = new Date();
                now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
                const quickFormTitle = `Quick Note - ${now.toLocaleDateString('en-US')} ${now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit'})}`;

                const initialFormData = {
                    id: currentFormId,
                    formNumber: newFormNumber,
                    title: quickFormTitle,
                    beneficiary: '',
                    type: 'other', // Default to 'other' for quick notes
                    plannedDateTime: now.toISOString(),
                    address: '',
                    initialNotes: '',
                    sections: [],
                    status: 'not-started',
                    createdAt: now.toISOString(),
                    lastModified: now.toISOString()
                };
                let allForms = (await idbKeyval.get('formsMetadata')) || [];
                allForms.unshift(initialFormData); // Add to top
                await idbKeyval.set('formsMetadata', allForms);
                alert(`New quick form created: ${quickFormTitle}`);
            }

            const formData = {
                id: currentFormId,
                formNumber: (await idbKeyval.get('formsMetadata') || []).find(f => f.id === currentFormId)?.formNumber || null,
                title: formTitleInput.value.trim() || 'Untitled Form',
                beneficiary: formBeneficiaryInput.value.trim(),
                type: formTypeSelect.value,
                plannedDateTime: formPlannedDateInput.value ? new Date(formPlannedDateInput.value).toISOString() : null,
                address: formAddressInput.value.trim(),
                initialNotes: formInitialNotesInput.value.trim(),
                sections: selectedSections, 
                status: newStatus || (await idbKeyval.get('formsMetadata') || [])
                    .find(f => f.id === currentFormId)?.status || 'not-started',
                createdAt: (await idbKeyval.get('formsMetadata') || [])
                    .find(f => f.id === currentFormId)?.createdAt || new Date().toISOString(),
                lastModified: new Date().toISOString() 
            };

            let allForms = (await idbKeyval.get('formsMetadata')) || [];
            const index = allForms.findIndex(f => f.id === currentFormId);
            
            if (index !== -1) {
                // Editing existing form
                allForms[index] = formData;
            } else {
                // This path should ideally not be taken if currentFormId is set above
                // but as a fallback for robustness:
                let lastFormSequenceNumber = (await idbKeyval.get('lastFormSequenceNumber')) || 0;
                formData.formNumber = ++lastFormSequenceNumber;
                await idbKeyval.set('lastFormSequenceNumber', lastFormSequenceNumber);
                allForms.unshift(formData);
            }
            
            await idbKeyval.set('formsMetadata', allForms);
            
            // Update UI title if not quick form
            const currentForm = allForms.find(f => f.id === currentFormId);
            // pageTitle.textContent = `Edit Form No. ${currentForm?.formNumber || 'N/A'}`; // Removed specific pageTitle
            // backToFormsText.textContent = `Form No. ${currentForm?.formNumber || 'N/A'}`; // This button is now removed from header

            return formData.id; 
        }

        // Debounce function to limit function calls (for auto-save)
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }
        
        // Save a dictated text segment
        async function saveDictatedSegment(text) {
            if (!currentFormId) {
                // This scenario should be handled by startNativeDictationProcess
                alert('Error: No active form to save the dictated note to. Please start dictation first.');
                return;
            }
            if (!text || text.trim().length === 0) {
                alert('Cannot save an empty note.');
                return;
            }

            const now = new Date();
            const segmentId = crypto.randomUUID();

            const segmentMetaData = {
                id: segmentId,
                formId: currentFormId,
                name: `Dictated Note - ${now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`, 
                status: 'draft', 
                recordedAtTime: now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
                recordedAtDate: now.toLocaleDateString('en-US'),
                duration: Math.ceil(text.trim().split(/\s+/).length / 2.5), // Estimate duration based on word count (avg 150 wpm)
                text: text.trim(), // Store the actual dictated text
                tasks: [] // Tasks will be extracted manually later
            };

            const formRecordings = (await idbKeyval.get(`formRecordings-${currentFormId}`)) || [];
            formRecordings.unshift(segmentMetaData); // Add new segment to the top
            await idbKeyval.set(`formRecordings-${currentFormId}`, formRecordings);

            // Update form status to "in-progress" if it's not already completed
            let allForms = (await idbKeyval.get('formsMetadata')) || [];
            const formIndex = allForms.findIndex(f => f.id === currentFormId);
            if (formIndex !== -1) {
                if (allForms[formIndex].status !== 'completed' && allForms[formIndex].status !== 'in-progress') {
                    allForms[formIndex].status = 'in-progress'; 
                }
                allForms[formIndex].lastModified = new Date().toISOString(); 
                await idbKeyval.set('formsMetadata', allForms);
            }
            
            renderFormRecordingsList(); 
            alert('Dictated note saved successfully!');
        }

        // Render dictated notes specific to this form
        async function renderFormRecordingsList() {
            const container = document.getElementById('formRecordingsList');
            if (!container) return;

            const recordings = (await idbKeyval.get(`formRecordings-${currentFormId}`)) || [];
            container.innerHTML = '';

            if (recordings.length === 0) {
                noRecordingsMessage.style.display = 'block';
                return;
            } else {
                noRecordingsMessage.style.display = 'none';
            }

            for (const rec of recordings) {
                const card = document.createElement('div');
                card.className = 'glass p-4 text-white relative flex flex-col items-start rounded-xl mb-4';
                card.innerHTML = `
                    <div class="flex items-center mb-2">
                        <span class="font-medium text-lg">${rec.name}</span>
                    </div>
                    <div class="pl-0 text-sm text-indigo-100 mb-2">
                        Dictated at ${rec.recordedAtTime} on ${rec.recordedAtDate} (approx. ${rec.duration}s)
                    </div>
                    <div class="pl-0 text-indigo-100 text-sm overflow-hidden text-ellipsis whitespace-nowrap max-w-full">
                        "${rec.text.substring(0, 100)}${rec.text.length > 100 ? '...' : ''}"
                    </div>
                    <div class="pl-0 mt-2 w-full flex justify-between items-center text-sm">
                        <a href="record-details.html?id=${rec.id}" class="text-indigo-300 underline hover:text-indigo-400 transition-colors">
                            View/Extract Tasks
                        </a>
                        <button onclick="deleteSegment('${rec.id}')" class="text-red-400 underline hover:text-red-500 transition-colors">
                            Delete
                        </button>
                    </div>
                `;
                container.appendChild(card);
            }
        }

        async function deleteSegment(id) {
            if (!confirm('Are you sure you want to delete this dictated note?')) return;

            let formRecordings = (await idbKeyval.get(`formRecordings-${currentFormId}`)) || [];
            formRecordings = formRecordings.filter(rec => rec.id !== id);
            await idbKeyval.set(`formRecordings-${currentFormId}`, formRecordings);
            
            alert('Dictated note deleted.');
            renderFormRecordingsList(); 
            // If all segments are deleted, you might want to consider changing form status back to 'not-started'
            // or prompting the user. For F1, just re-render is fine.
        }

        // --- Event Listeners ---

        // Fixed Dictate/Stop Button
        dictateToggleButton.addEventListener('click', () => {
            if (isDictating) {
                stopNativeDictationProcess(true);
            } else {
                startNativeDictationProcess();
            }
        });

        // Explicit Save Form Details button
        saveFormDetailsButton.addEventListener('click', async () => {
            if (!formTitleInput.value.trim()) {
                alert('Please provide an Objective Title for the form.');
                return;
            }
            const formId = await saveFormData();
            // Re-render recordings list to reflect updated formId if it was a new quick form
            if (formId) {
                currentFormId = formId; // Ensure currentFormId is set for subsequent actions
                await renderFormRecordingsList(); 
            }
            alert('Form data saved!');
            toggleAccordion('formDetailsContent', document.querySelector('#formDetailsAccordion .accordion-header'), true);
        });

        // Auto-save on input changes (debounced)
        formCreationForm.addEventListener('input', debounce(async () => {
            if (formTitleInput.value.trim()) { // Only auto-save if title is present
                await saveFormData(); 
            }
        }, 1000)); 
        
        // Post-dictation buttons
        saveDictatedTextButton.addEventListener('click', async () => {
            if (simulatedDictatedText) {
                await saveDictatedSegment(simulatedDictatedText);
            }
            // Reset dictation UI after saving
            stopNativeDictationProcess(false); // Do not mark as successful to clear controls
            transcriptionText.textContent = ''; // Clear display
            simulatedDictatedText = ''; // Clear accumulated text
        });

        discardDictatedTextButton.addEventListener('click', () => {
            if (confirm('Are you sure you want to discard this dictated note? It will not be saved.')) {
                transcriptionText.textContent = '';
                simulatedDictatedText = '';
                alert('Dictated note discarded.');
            }
            // Reset dictation UI after discarding
            stopNativeDictationProcess(false); // Do not mark as successful to clear controls
            transcriptionText.textContent = ''; // Clear display
            simulatedDictatedText = ''; // Clear accumulated text
        });

        viewTranscriptReportButton.addEventListener('click', async () => {
            if (currentFormId) {
                window.location.href = `record-details.html?id=${currentFormId}`; 
            } else {
                alert('No form available to view report. Please dictate or save form details first.');
            }
        });

        // --- Page Load Logic ---

        // Function to load and display form details and dictated notes
        async function loadFormDetailsAndRecordings() {
            const params = new URLSearchParams(window.location.search);
            currentFormId = params.get('id'); // Get form ID from URL

            if (currentFormId) {
                const allForms = (await idbKeyval.get('formsMetadata')) || [];
                const form = allForms.find(f => f.id === currentFormId);

                if (form) {
                    formTitleInput.value = form.title || '';
                    formBeneficiaryInput.value = form.beneficiary || '';
                    formTypeSelect.value = form.type || 'inspection';
                    if (form.plannedDateTime) {
                        formPlannedDateInput.value = new Date(form.plannedDateTime).toISOString().slice(0, 16);
                    } else {
                        formPlannedDateInput.value = '';
                    }
                    formAddressInput.value = form.address || '';
                    formInitialNotesInput.value = form.initialNotes || '';
                    setupAccordions(true); // Editing an existing form
                } else {
                    alert('Form not found. Starting a new blank form.');
                    currentFormId = null; 
                    window.history.replaceState(null, null, 'new-form.html'); 
                    setupAccordions(false); // Starting a new form
                }
            } else {
                // For a completely new session or coming from My Forms "New Form" equivalent
                const now = new Date();
                now.setMinutes(now.getMinutes() - now.getTimezoneOffset()); 
                formPlannedDateInput.value = now.toISOString().slice(0, 16); // Pre-fill with current date/time
                setupAccordions(false); // Starting a new form
            }
            
            // Render recordings only if currentFormId exists
            if (currentFormId) {
                 await renderFormRecordingsList();
                 // Enable View Transcript button if there are existing recordings
                 const formRecordings = (await idbKeyval.get(`formRecordings-${currentFormId}`)) || [];
                 if (formRecordings.length > 0) {
                     viewTranscriptReportButton.disabled = false;
                 }
            } else {
                noRecordingsMessage.style.display = 'block'; // Ensure message is visible if no ID
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await loadFormDetailsAndRecordings(); 
            stopNativeDictationProcess(false); // Initialize UI to non-dictating state
        });
    </script>
</body>
</html>
