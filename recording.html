<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Înregistrare – AudioForm</title>

  <link rel="manifest" href="/manifest.json" />
  <meta name="theme-color" content="#1e40af" />

  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">

  <script src="https://cdn.tailwindcss.com"></script>

  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />
  
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Keyframes for simple bounce animation on AI icon */
    @keyframes bounce {
      0%, 100% { transform: translateY(-25%); animation-timing-function: cubic-bezier(0.8, 0, 1, 1); }
      50% { transform: translateY(0); animation-timing-function: cubic-bezier(0, 0, 0.2, 1); }
    }
    .animate-bounce-custom {
      animation: bounce 1s infinite;
    }

    /* Keyframes for the initial pulse animation on the start button */
    @keyframes initial-pulse {
        0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
        70% { transform: scale(1.05); box-shadow: 0 0 0 15px rgba(220, 38, 38, 0); }
        100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
    }
    .animate-initial-pulse {
        animation: initial-pulse 2s infinite;
    }

    /* Keyframes for the pulsating red bullet (recording status) */
    @keyframes pulse-dot {
        0% { transform: scale(0.8); opacity: 1; }
        50% { transform: scale(1.2); opacity: 0.5; }
        100% { transform: scale(0.8); opacity: 1; }
    }
    .animate-pulse-dot {
        animation: pulse-dot 1.5s ease-out infinite;
    }
    /* Simple audio wave simulation for non-visualizer browsers */
    @keyframes wave-sim {
      0% { background-position: 0% 0%; }
      100% { background-position: 100% 0%; }
    }
    .audio-wave-sim {
      background: linear-gradient(to right, #60A5FA 0%, #3B82F6 25%, #2563EB 50%, #3B82F6 75%, #60A5FA 100%);
      background-size: 200% 100%;
      animation: wave-sim 1s linear infinite;
    }
  </style>
</head>

<body class="bg-gray-50 text-gray-800 antialiased min-h-screen flex flex-col justify-between
             dark:bg-gray-900 dark:text-gray-100 transition-colors duration-300">
  
  <header class="p-4 bg-white shadow-md dark:bg-gray-800 sticky top-0 z-40">
    <a href="dashboard.html" class="flex items-center text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors duration-200" aria-label="Înapoi la Dashboard">
      <i class="fas fa-arrow-left mr-2"></i>
      <h1 class="text-lg font-semibold text-center text-gray-900 dark:text-gray-50 flex-grow">Înregistrare Raport Nou</h1>
    </a>
  </header>

  <main class="flex-grow px-4 py-6 space-y-6 max-w-xl mx-auto w-full text-center">
    <div id="plugin-slot-recording-top" class="w-full">
      </div>

    <section id="template-info" data-testid="template-info-section" class="bg-white dark:bg-gray-800 shadow rounded-lg p-4 space-y-2 mb-6 transition-transform duration-300 ease-in-out">
      <h2 class="text-base font-medium text-gray-700 dark:text-gray-200">Șablon selectat:</h2>
      <p id="template-name" data-testid="template-name-display" class="text-xl font-semibold text-blue-700 dark:text-blue-400">Încărcare...</p>
      <p id="template-id-display" class="text-xs text-gray-400 dark:text-gray-500 hidden">ID: N/A</p>
    </section>

    <section id="recording-section" class="flex flex-col items-center justify-center space-y-6 transition-opacity duration-300 ease-in-out">
      <button id="start-recording" data-testid="start-recording-button" class="bg-red-600 hover:bg-red-700 text-white px-8 py-4 rounded-full shadow-lg text-xl font-bold flex items-center gap-3
              transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-400 focus:ring-opacity-75
              animate-initial-pulse"
              aria-label="Începe înregistrarea vocală">
        <i class="fas fa-circle text-sm"></i> Începe Înregistrarea
      </button>

      <div id="recording-status" data-testid="recording-status-display" class="hidden flex flex-col items-center space-y-4 opacity-0 transition-opacity duration-300 ease-in-out">
        <div class="flex items-center gap-2 text-lg font-medium text-gray-600 dark:text-gray-300">
            <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse-dot" data-testid="recording-bullet"></div> <span>Înregistrare în curs...</span>
        </div>
        
        <div class="w-full max-w-xs h-10 bg-gray-200 dark:bg-gray-700 rounded-full flex items-center justify-center relative overflow-hidden audio-wave-sim">
            <div id="timer" data-testid="recording-timer" class="text-3xl font-bold text-gray-800 dark:text-gray-100 z-10">00:00</div>
            </div>
        
        <div class="flex gap-4 mt-4">
            <button id="pause-recording" data-testid="pause-recording-button" class="bg-yellow-500 hover:bg-yellow-600 text-white px-5 py-2 rounded-full shadow transition duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-yellow-400"
                    aria-label="Pauză înregistrare">
              <i class="fas fa-pause"></i> Pauză
            </button>
            <button id="stop-recording" data-testid="stop-recording-button" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2 rounded-full shadow transition duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400"
                    aria-label="Oprește și salvează înregistrarea">
              <i class="fas fa-stop"></i> Oprește și Salvează
            </button>
        </div>
      </div>

      <div id="audio-preview" data-testid="audio-preview-container" class="hidden bg-white dark:bg-gray-800 shadow rounded-lg p-4 w-full max-w-xs mx-auto mt-6 transition-opacity duration-300 ease-in-out">
        <p class="text-base font-medium text-gray-700 dark:text-gray-200 mb-2">Previzualizare înregistrare:</p>
        <audio id="audio-player" data-testid="audio-player" controls class="w-full mt-2"></audio>
      </div>

      <div id="error-message" data-testid="error-message-display" class="hidden text-red-600 dark:text-red-400 mt-4 text-sm font-medium transition-opacity duration-300 ease-in-out">
        <i class="fas fa-exclamation-triangle mr-1"></i>
        <span></span>
      </div>
    </section>

    <div id="plugin-slot-recording-bottom" class="mt-6 w-full">
      </div>

    <div class="mt-6">
      <a href="dashboard.html" data-testid="cancel-button" class="text-gray-500 hover:text-red-600 text-sm underline transition duration-150 ease-in-out dark:text-gray-300 dark:hover:text-red-400">
        <i class="fas fa-arrow-left mr-1"></i> Anulează și revino la Dashboard
      </a>
    </div>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', async () => { // Marked as async for getUserMedia
      // Determine if debug mode is active globally
      const isDebugMode = location.search.includes('debug=true');

      // Helper for secure logging
      const secureLog = (message, ...args) => {
        if (isDebugMode) {
          console.log(`[DEBUG] ${message}`, ...args);
        }
      };

      // === Global Dark Mode Autodetect & Apply ===
      const applyDarkMode = () => {
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      };
      applyDarkMode();
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyDarkMode);

      // === PWA - Register Service Worker ===
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then(registration => secureLog('PWA ServiceWorker registered:', registration))
            .catch(error => console.error('PWA ServiceWorker registration failed:', error)); // Always log critical errors
        });
      }

      // === DOM Elements for recording logic ===
      const startBtn = document.getElementById('start-recording');
      const pauseBtn = document.getElementById('pause-recording');
      const stopBtn = document.getElementById('stop-recording');
      const recordingUI = document.getElementById('recording-status');
      const timerEl = document.getElementById('timer');
      const audioPlayer = document.getElementById('audio-player');
      const previewContainer = document.getElementById('audio-preview');
      const templateNameEl = document.getElementById('template-name');
      const templateIdDisplayEl = document.getElementById('template-id-display');
      const errorMessageEl = document.getElementById('error-message');

      // === MediaRecorder State Variables ===
      let mediaRecorder;
      let audioChunks = [];
      let stream = null; // Global stream reference to stop tracks later
      let timerInterval = null;
      let seconds = 0;
      let isPaused = false; // Tracks if MediaRecorder is paused

      // === Audio Cues (Feedback vocal) ===
      const audioStart = new Audio('/audio/start-recording.mp3'); 
      const audioStop = new Audio('/audio/stop-recording.mp3');
      const audioPause = new Audio('/audio/pause-recording.mp3');
      const audioResume = new Audio('/audio/resume-recording.mp3');

      // Add simple error handling for audio loading
      [audioStart, audioStop, audioPause, audioResume].forEach(audio => {
          audio.onerror = () => secureLog(`Warning: Could not load audio file: ${audio.src}`);
      });


      // === Utility Functions ===
      const formatTime = (sec) => {
        const m = String(Math.floor(sec / 60)).padStart(2, '0');
        const s = String(sec % 60).padStart(2, '0');
        return `${m}:${s}`;
      };

      const updateTimer = () => {
        seconds++;
        timerEl.textContent = formatTime(seconds);
      };

      // Function to stop all media tracks from the stream
      const stopMediaTracks = () => {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            secureLog('Media tracks stopped.');
        }
      };

      // Function to handle browser fallback for MediaRecorder
      const handleMediaRecorderFallback = () => {
          errorMessageEl.classList.remove('hidden');
          errorMessageEl.querySelector('span').textContent = 'Browserul tău nu suportă înregistrarea audio. Te rugăm să folosești un browser modern (Chrome, Firefox, Edge).';
          startBtn.disabled = true; // Disable start button
          startBtn.classList.add('opacity-50', 'cursor-not-allowed');
          secureLog('MediaRecorder not supported. Fallback message displayed.');
      };

      // === IndexedDB setup for persistent audio fallback ===
      // This is conceptual for the wireframe. Real implementation would be more complex.
      const DB_NAME = 'AudioFormDB';
      const STORE_NAME = 'audioRecordings';
      let db;

      const openIndexedDB = () => {
          return new Promise((resolve, reject) => {
              const request = indexedDB.open(DB_NAME, 1);

              request.onupgradeneeded = (event) => {
                  const db = event.target.result;
                  if (!db.objectStoreNames.contains(STORE_NAME)) {
                      db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                  }
              };

              request.onsuccess = (event) => {
                  db = event.target.result;
                  secureLog('IndexedDB opened successfully.');
                  resolve(db);
              };

              request.onerror = (event) => {
                  console.error('IndexedDB error:', event.target.error); // Always log critical errors
                  reject(event.target.error);
              };
          });
      };

      const saveAudioBlobToIndexDB = async (blob, templateData, duration) => {
          if (!db) {
              secureLog('IndexedDB not initialized. Skipping persistent save.');
              return;
          }
          try {
              const transaction = db.transaction([STORE_NAME], 'readwrite');
              const store = transaction.objectStore(STORE_NAME);
              const recordingId = `rec_${Date.now()}`;
              const recordingData = {
                  id: recordingId,
                  blob: blob, // Store the Blob directly
                  template: templateData,
                  duration: duration,
                  timestamp: new Date().toISOString()
              };
              const request = store.add(recordingData);
              request.onsuccess = () => {
                  secureLog('Audio Blob saved to IndexedDB:', recordingId);
                  // Optionally pass recordingId to edit.html instead of Blob URL
                  // This enables retrieving the Blob from IndexedDB in edit.html
                  sessionStorage.setItem('audioFormTempRecordingId', recordingId);
              };
              request.onerror = (event) => {
                  console.error('Error saving Blob to IndexedDB:', event.target.error); // Always log critical errors
              };
          } catch (e) {
              console.error('IndexedDB transaction failed:', e); // Always log critical errors
          }
      };
      
      // Initialize IndexedDB on page load
      if ('indexedDB' in window) {
          openIndexedDB().catch(e => secureLog('Failed to open IndexedDB:', e));
      } else {
          secureLog('IndexedDB not supported in this browser.');
      }


      // === Preluare șablon din sessionStorage (cu token) ===
      const templateNameEl = document.getElementById('template-name');
      const templateIdDisplayEl = document.getElementById('template-id-display');
      const urlParams = new URLSearchParams(window.location.search);
      const ref = urlParams.get('ref'); // Retrieve the token from the URL
      let templateData = null; // Store template data globally

      if (ref) {
        try {
          const storedData = sessionStorage.getItem(ref);
          if (storedData) {
            templateData = JSON.parse(storedData);
            templateNameEl.textContent = templateData.name || 'Nume necunoscut';
            if (templateData.id) {
                templateIdDisplayEl.textContent = `ID: ${templateData.id}`;
                if (isDebugMode) templateIdDisplayEl.classList.remove('hidden');
            }
            sessionStorage.removeItem(ref); // Clear sessionStorage after use
            secureLog(`Template loaded: ${templateData.name} (${templateData.id})`);
          } else {
            templateNameEl.textContent = 'Șablon indisponibil';
            errorMessageEl.classList.remove('hidden');
            errorMessageEl.querySelector('span').textContent = 'Datele șablonului nu au putut fi încărcate. Vă rugăm să reveniți la Dashboard.';
            secureLog('Error: Template data missing for provided ref token.', ref);
          }
        } catch (e) {
          console.error('Eroare la citirea sau parsarea șablonului din sessionStorage:', e);
          templateNameEl.textContent = 'Eroare la încărcare';
          errorMessageEl.classList.remove('hidden');
          errorMessageEl.querySelector('span').textContent = 'A apărut o eroare la încărcarea șablonului. Vă rugăm să reveniți la Dashboard.';
        }
      } else {
        templateNameEl.textContent = 'Șablon nespecificat';
        errorMessageEl.classList.remove('hidden');
        errorMessageEl.querySelector('span').textContent = 'Niciun șablon nu a fost selectat. Vă rugăm să reveniți la Dashboard.';
        secureLog('Error: No ref token provided in URL.');
      }


      // === Real MediaRecorder Implementation ===
      if (!navigator.mediaDevices || !window.MediaRecorder) {
          handleMediaRecorderFallback(); // Display fallback message if API is not supported
          return; // Exit if MediaRecorder is not supported
      }

      startBtn.addEventListener('click', async () => {
        if (!templateData) { // Prevent starting if template data failed to load
            errorMessageEl.classList.remove('hidden');
            errorMessageEl.querySelector('span').textContent = 'Nu se poate începe înregistrarea fără un șablon valid.';
            secureLog('Attempted to start recording without valid template data.');
            return;
        }

        try {
          // Play start sound
          audioStart.play().catch(e => secureLog('Audio play failed:', e));

          // Request microphone access
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          secureLog('Microphone access granted.');

          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];
          seconds = 0; // Reset timer for new recording
          timerEl.textContent = '00:00';
          previewContainer.classList.add('hidden'); // Hide preview if exists from previous recording

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = async () => {
            clearInterval(timerInterval); // Stop timer on actual mediaRecorder stop
            stopMediaTracks(); // Stop microphone stream

            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const audioUrl = URL.createObjectURL(audioBlob);
            
            // Store Blob URL in sessionStorage for short-term use in edit.html
            sessionStorage.setItem('audioFormBlobUrl', audioUrl);
            sessionStorage.setItem('audioFormTempRecording', JSON.stringify({
              duration: seconds,
              timestamp: new Date().toISOString(),
              template: templateData // Pass template data for edit.html
            }));
            secureLog(`Recording stopped. Blob URL created: ${audioUrl}. Duration: ${seconds}s`);

            // Optional: Save to IndexedDB for more persistent storage / offline access
            if ('indexedDB' in window && db) {
                await saveAudioBlobToIndexDB(audioBlob, templateData, seconds);
            }
            
            // Show audio player for preview
            if (audioPlayer && previewContainer) {
              audioPlayer.src = audioUrl;
              previewContainer.classList.remove('hidden');
              // Ensure audio player is loaded and functional
              audioPlayer.load();
              secureLog('Audio preview loaded.');
            }

            // Redirect after a short delay for UX
            document.body.classList.add('opacity-0', 'transition-opacity', 'duration-500');
            setTimeout(() => {
                window.location.href = 'edit.html';
            }, 500); // Give user a moment to see preview/feedback
          };

          mediaRecorder.onerror = (event) => {
              console.error('MediaRecorder error:', event.error); // Always log critical errors
              errorMessageEl.classList.remove('hidden');
              errorMessageEl.querySelector('span').textContent = `Eroare înregistrare: ${event.error.name}. Reîncearcă.`;
              stopMediaTracks(); // Ensure tracks are stopped on error
              clearInterval(timerInterval); // Stop timer
              isRecording = false; // Reset state
              isPaused = false;
              // Reset UI to initial state if needed
              startBtn.classList.remove('hidden');
              recordingUI.classList.add('hidden');
          };


          // Start recording
          mediaRecorder.start(); // Start capturing audio
          secureLog('MediaRecorder started.');

          // Update UI
          startBtn.classList.add('hidden'); // Hide start button
          recordingUI.classList.remove('hidden'); // Show recording UI
          recordingUI.classList.add('opacity-100'); // Ensure it fades in correctly

          // Start timer
          timerInterval = setInterval(updateTimer, 1000);
          isRecording = true;
          isPaused = false;

        } catch (err) {
          console.error('🎙️ Eroare la inițializarea microfonului:', err); // Always log critical errors
          errorMessageEl.classList.remove('hidden');
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            errorMessageEl.querySelector('span').textContent = 'Accesul la microfon a fost refuzat. Te rugăm să acorzi permisiunea în setările browserului.';
          } else if (err.name === 'NotFoundError') {
            errorMessageEl.querySelector('span').textContent = 'Niciun microfon găsit. Asigură-te că un microfon este conectat și funcțional.';
          } else {
            errorMessageEl.querySelector('span').textContent = `Eroare microfon: ${err.name}. Reîncearcă.`;
          }
          // Reset UI to initial state
          startBtn.classList.remove('hidden');
          recordingUI.classList.add('hidden', 'opacity-0');
        }
      });

      pauseBtn.addEventListener('click', () => {
        if (!mediaRecorder || !isRecording) {
            secureLog('Attempted pause when not recording or no recorder.');
            return;
        }

        if (mediaRecorder.state === 'recording') {
          mediaRecorder.pause();
          clearInterval(timerInterval);
          isPaused = true;
          pauseBtn.innerHTML = '<i class="fas fa-play"></i> Continuă';
          pauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
          pauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
          audioPause.play().catch(e => secureLog('Audio play failed:', e));
          secureLog('⏸️ Recording paused.');
        } else if (mediaRecorder.state === 'paused') {
          mediaRecorder.resume();
          startTimer();
          isPaused = false;
          pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pauză';
          pauseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
          pauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
          audioResume.play().catch(e => secureLog('Audio play failed:', e));
          secureLog('▶️ Recording resumed.');
        }
      });

      stopBtn.addEventListener('click', () => {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
            secureLog('Attempted stop when recorder is inactive.');
            return;
        }
        audioStop.play().catch(e => secureLog('Audio play failed:', e));
        mediaRecorder.stop(); // This will trigger onstop event
        secureLog('🛑 MediaRecorder stop signal sent.');
      });


      // === Plugin slot handlers ===
      const pluginSlotRecordingTop = document.getElementById('plugin-slot-recording-top');
      const pluginSlotRecordingBottom = document.getElementById('plugin-slot-recording-bottom');

      if (window.AudioFormPlugin) {
        if (typeof window.AudioFormPlugin.renderRecordingTop === 'function') {
          pluginSlotRecordingTop.appendChild(window.AudioFormPlugin.renderRecordingTop());
          secureLog('Plugin rendered in top slot.');
        }
        if (typeof window.AudioFormPlugin.renderRecordingBottom === 'function') {
          pluginSlotRecordingBottom.appendChild(window.AudioFormPlugin.renderRecordingBottom());
          secureLog('Plugin rendered in bottom slot.');
        }
      }
      
      // === Debug Mode Integration ===
      if (isDebugMode) {
        console.log('🧪 DEBUG MODE ACTIVAT pentru Recording Page');
        templateIdDisplayEl.classList.remove('hidden');
      }
    });
  </script>
</body>
</html>