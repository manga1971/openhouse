<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Blink Test ‚Äì LiYE Vision</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <link rel="icon" href="favicon.ico" />
    <style>
        body {
            font-family: sans-serif;
        }
        /* Styles for video and canvas elements, both visible for debugging */
        #raw_video_feed {
            display: block;
            border: 2px solid red;
            width: 640px;
            height: 480px;
            margin: auto;
            margin-bottom: 10px;
        }
        #output_canvas {
            border: 2px solid #3b82f6; /* Light Blue border for LiYE theme */
            display: block;
            margin: auto;
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
            font-size: 0.875rem;
            color: #4b5563;
        }
        .checkbox-container input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #3b82f6;
        }
        #badge-success.hidden {
            display: none !important;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 text-center">

    <h1 class="text-3xl font-extrabold mb-4 text-blue-800">Blink Test üëÅÔ∏è LiYE Vision</h1>
    
    <div id="privacy-warning" class="mb-4 text-gray-700 bg-red-100 border-l-4 border-red-500 p-4" role="alert">
        <p class="font-bold">**Privacy:**</p>
        <p>Camera images are processed **exclusively on your device** and are not stored, transmitted, or accessed by the developer.</p>
        <div class="checkbox-container">
            <input type="checkbox" id="hide-privacy-warning" class="form-checkbox">
            <label for="hide-privacy-warning">Do not show this message again</label>
        </div>
    </div>

    <div id="instructions" class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4" role="alert">
        <p class="font-bold">Instructions:</p>
        <p>Position your face within the frame and look directly at the camera. LiYE will observe you and provide feedback.</p>
        <div class="checkbox-container">
            <input type="checkbox" id="hide-instructions" class="form-checkbox">
            <label for="hide-instructions">Do not show these instructions again</label>
        </div>
    </div>

    <video id="raw_video_feed" autoplay muted playsinline></video> 
    <canvas id="output_canvas" width="640" height="480"></canvas>

    <p id="status-message" class="mt-2 text-md text-gray-600">Awaiting camera initialization...</p>
    <p id="live-feedback" class="text-sm mt-2 text-gray-500"></p> 
    <p id="offline-status" class="text-sm text-yellow-600 mt-2 hidden">Offline mode active. Some functionalities may be limited.</p> 

    <div class="mt-4 mb-4 flex justify-center items-center gap-4" id="duration-selection-container">
        <span class="text-gray-700 font-medium">Monitoring Duration:</span>
        <label class="inline-flex items-center">
            <input type="radio" name="monitorDuration" value="60" checked class="form-radio text-blue-600">
            <span class="ml-2 text-gray-700">60 seconds</span>
        </label>
        <label class="inline-flex items-center">
            <input type="radio" name="monitorDuration" value="120" class="form-radio text-blue-600">
            <span class="ml-2 text-gray-700">120 seconds</span>
        </label>
    </div>

    <button id="start-camera-btn" class="px-6 py-3 bg-blue-600 text-white rounded hover:bg-blue-700 transition mt-4">
        Start Camera
    </button>

    <div id="test-ui" class="mt-6 hidden">
        <div class="text-lg font-medium text-gray-700 mb-2">Time remaining: <span id="time-left">60</span> seconds</div>
        <div class="w-full h-4 bg-gray-300 rounded">
            <div id="progress-bar" class="h-4 bg-blue-500 rounded" style="width: 0%; transition: width 1s linear;"></div>
        </div>
    </div>

    <p id="test-result" class="mt-6 text-xl font-bold text-gray-800 hidden"></p>

    <div id="score-visual" class="mt-4 hidden">
        <div class="w-full h-6 bg-gray-200 rounded">
            <div id="score-bar" class="h-6 text-sm font-bold text-white text-center leading-6 rounded"></div>
        </div>
        <div id="score-emoji" class="text-4xl mt-2"></div>
    </div>

    <audio id="background-music" loop preload="auto">
        <source src="audio/calm-background-117564.mp3" type="audio/mpeg">
    </audio>
    <audio id="start-sound" preload="auto">
        <source src="audio/short-success-sound-glitch-40993.mp3" type="audio/mpeg">
    </audio>
    <audio id="end-sound" preload="auto">
        <source src="audio/completion-sound-148813.mp3" type="audio/mpeg">
    </audio>

    <div class="mt-4 flex justify-center gap-4">
        <button id="stop-continue-btn" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded hover:bg-gray-600 transition hidden">
            Stop Monitoring
        </button>
        <button id="restart-btn" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded hover:bg-blue-700 transition hidden">
            Restart Monitoring
        </button>
    </div>
    <a href="exercitii.html" id="relax-link" class="mt-4 text-blue-600 underline hidden">üîÅ Relax your eyes now</a> 
    
    <a href="index.html" class="block mt-6 text-sm text-gray-500 hover:text-blue-600 underline">‚Üê Back to Main Page</a>

    <div id="badge-success" class="fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 hidden opacity-0 transition-opacity duration-500">
        üü¢ Congratulations! Your gaze is excellent!
    </div>


    <script>
        // =====================================================================================
        // UI Elements (Global Declarations)
        // =====================================================================================
        const rawVideoFeed = document.getElementById("raw_video_feed"); 
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const statusMessage = document.getElementById("status-message");
        const liveFeedback = document.getElementById("live-feedback"); 
        const offlineStatus = document.getElementById("offline-status"); 

        const startCameraBtn = document.getElementById("start-camera-btn"); 
        const durationSelectionContainer = document.getElementById("duration-selection-container"); 
        const radioButtonsMonitorDuration = document.querySelectorAll('input[name="monitorDuration"]'); 

        const privacyWarning = document.getElementById("privacy-warning"); 
        const hidePrivacyWarningCheckbox = document.getElementById("hide-privacy-warning"); 
        const instructionsDiv = document.getElementById("instructions"); 
        const hideInstructionsCheckbox = document.getElementById("hide-instructions"); 

        const timeLeftEl = document.getElementById("time-left");
        const progressBar = document.getElementById("progress-bar");
        const testUI = document.getElementById("test-ui");
        const testResult = document.getElementById("test-result");
        const restartBtn = document.getElementById("restart-btn");
        const relaxLink = document.getElementById("relax-link"); 
        const backgroundMusic = document.getElementById("background-music");
        const startSound = document.getElementById("start-sound"); 
        const endSound = document.getElementById("end-sound");     
        const badgeSuccess = document.getElementById("badge-success"); 

        const scoreVisual = document.getElementById("score-visual");
        const scoreBar = document.getElementById("score-bar");
        const scoreEmoji = document.getElementById("score-emoji");

        const stopContinueBtn = document.getElementById("stop-continue-btn"); // Added

        // MediaPipe Landmark Indices
        const LEFT_EYE_TOP = 159;
        const LEFT_EYE_BOTTOM = 145;
        const RIGHT_EYE_TOP = 386;
        const RIGHT_EYE_BOTTOM = 374;
        const LEFT_IRIS_CENTER = 468;
        const RIGHT_IRIS_CENTER = 473;

        // Configuration
        const EAR_THRESHOLD = 0.015; 
        const BLINK_HOLD_FRAMES = 2; 
        const BLINK_RESET_FRAMES = 5; 
        // STABLE_THRESHOLD is not used in the new "Observe Me" workflow
        const MAX_FACE_LOST_FRAMES = 150; 

        // Global State Variables
        let blinkCount = 0;
        let isBlinking = false;
        let framesBelowThreshold = 0;
        let framesAboveThreshold = 0;
        let monitoringActive = false; // Renamed from testStarted for clarity
        let monitoringPaused = false; // Added for Stop/Continue logic
        let monitoringTimer; // Renamed from testTimer
        let monitoringDuration = 60; // Default, will be updated by radio buttons
        let currentSecond = 0;
        let faceLostCounter = 0; 
        window.lastProcessedLandmarks = null; 

        // =====================================================================================
        // CORE: Indice Lumina Calculation Functions
        // =====================================================================================

        function calculateEyeVerticalDistance(top, bottom) {
            return Math.hypot(top.y - bottom.y);
        }

        function calculateBlinkScore(blinksPerMinute) {
            const OPTIMAL_MIN = 12;
            const OPTIMAL_MAX = 22;
            const EXTREME_LOW = 5;
            const EXTREME_HIGH = 30;

            if (blinksPerMinute >= OPTIMAL_MIN && blinksPerMinute <= OPTIMAL_MAX) {
                return 100; 
            } else if (blinksPerMinute < EXTREME_LOW || blinksPerMinute > EXTREME_HIGH) {
                return 20; 
            } else if (blinksPerMinute >= EXTREME_LOW && blinksPerMinute < OPTIMAL_MIN) {
                return Math.round(20 + (blinksPerMinute - EXTREME_LOW) / (OPTIMAL_MIN - EXTREME_LOW) * 80);
            } else if (blinksPerMinute > OPTIMAL_MAX && blinksPerMinute <= EXTREME_HIGH) {
                return Math.round(20 + (EXTREME_HIGH - blinksPerMinute) / (EXTREME_HIGH - OPTIMAL_MAX) * 80);
            }
            return 0; 
        }

        function calculateLuminosityScore(canvasCtx, landmarks, canvasWidth, canvasHeight) {
            if (!landmarks) return 0;

            let totalBrightness = 0;
            let pixelCount = 0;

            const irisLandmarkIndices = [LEFT_IRIS_CENTER, RIGHT_IRIS_CENTER];

            irisLandmarkIndices.forEach(index => {
                const irisCenter = landmarks[index];
                if (!irisCenter) return;

                const irisRadius = Math.round(canvasWidth * 0.015); 
                const x = Math.round(irisCenter.x * canvasWidth);
                const y = Math.round(irisCenter.y * canvasHeight);

                try {
                    const startX = Math.max(0, x - irisRadius);
                    const startY = Math.max(0, y - irisRadius);
                    const width = Math.min(irisRadius * 2, canvasWidth - startX);
                    const height = Math.min(irisRadius * 2, canvasHeight - startY);

                    if (width <= 0 || height <= 0) return; 

                    const imageData = canvasCtx.getImageData(
                        startX,
                        startY,
                        width,
                        height
                    );

                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const r = imageData.data[i];
                        const g = imageData.data[i + 1];
                        const b = imageData.data[i + 2];
                        const brightness = (r + g + b) / 3; 
                        totalBrightness += brightness;
                        pixelCount++;
                    }
                } catch (e) {
                    console.warn("Error getting ImageData for iris:", e);
                }
            });

            if (pixelCount === 0) return 0;

            const averageBrightness = totalBrightness / pixelCount;

            const minBrightness = 70;  
            const maxBrightness = 220; 

            let normalizedScore = (averageBrightness - minBrightness) / (maxBrightness - minBrightness) * 100;
            normalizedScore = Math.min(100, Math.max(0, normalizedScore)); 

            return Math.round(normalizedScore);
        }

        function calculateIndiceLumina(blinkScore, luminosityScore, w_blink = 0.6, w_lum = 0.4) {
            return Math.round(w_blink * blinkScore + w_lum * luminosityScore);
        }

        function interpretIndiceLumina(score) {
            if (score >= 80) return "‚ú® Your gaze is radiant! Perfect for creative activities.";
            if (score >= 60) return "üòä Your gaze is clear. A short break would maintain your focus.";
            if (score >= 40) return "üòü Your gaze seems tired. We recommend 3 minutes of eye exercises.";
            return "üò© Your gaze is strained. Stop for 5 minutes, breathe deeply, and look into the distance.";
        }

        // =====================================================================================
        // CORE: Monitoring Control Functions
        // =====================================================================================

        function startMonitoring() {
            monitoringActive = true; 
            monitoringPaused = false; // Ensure it's not paused when starting
            blinkCount = 0;
            currentSecond = 0;
            monitoringDuration = parseInt(document.querySelector('input[name="monitorDuration"]:checked').value); 
            timeLeftEl.textContent = monitoringDuration;
            
            // Hide duration selection and start button
            startCameraBtn.classList.add("hidden");
            durationSelectionContainer.classList.add("hidden");

            // Show monitoring UI elements
            testUI.classList.remove("hidden");
            testResult.classList.add("hidden"); // Hide results from previous test
            restartBtn.classList.remove("hidden"); // Show restart button
            stopContinueBtn.classList.remove("hidden"); // Show stop/continue button
            relaxLink.classList.add("hidden"); // Hide relax link
            badgeSuccess.classList.add("hidden", "opacity-0"); // Hide badge
            scoreVisual.classList.add("hidden"); // Hide score visual

            statusMessage.textContent = "Monitoring in progress...";
            backgroundMusic.currentTime = 0;
            backgroundMusic.play();
            startSound.currentTime = 0; 
            startSound.play().catch(e => console.log("Error playing start sound:", e));
            liveFeedback.textContent = ""; 

            monitoringTimer = setInterval(() => {
                if (!monitoringPaused) { // Only update timer if not paused
                    currentSecond++;
                    timeLeftEl.textContent = monitoringDuration - currentSecond;
                    const progress = (currentSecond / monitoringDuration) * 100;
                    progressBar.style.width = `${progress}%`;

                    if (currentSecond >= monitoringDuration) {
                        endMonitoring();
                    }
                }
            }, 1000);
        }

        function endMonitoring() {
            clearInterval(monitoringTimer);
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0; 
            endSound.currentTime = 0; 
            endSound.play().catch(e => console.log("Error playing end sound:", e));
            
            testUI.classList.add("hidden"); // Hide monitoring UI
            testResult.classList.remove("hidden"); // Show test results
            restartBtn.classList.remove("hidden"); // Show restart button
            stopContinueBtn.classList.add("hidden"); // Hide stop/continue button
            liveFeedback.textContent = ""; 

            const blinksPerMinute = (blinkCount / monitoringDuration) * 60;

            const blinkScore = calculateBlinkScore(blinksPerMinute);

            let luminosityScore = 0;
            if (window.lastProcessedLandmarks) {
                luminosityScore = calculateLuminosityScore(canvasCtx, window.lastProcessedLandmarks, canvasElement.width, canvasElement.height);
            } else {
                console.warn("Could not calculate LuminosityScore: landmarks missing.");
            }

            const indiceLumina = calculateIndiceLumina(blinkScore, luminosityScore);
            const feedback = interpretIndiceLumina(indiceLumina);

            testResult.textContent = `Blinks: ${blinksPerMinute.toFixed(1)}/min ‚Äì Light Index: ${indiceLumina} ‚Äì ${feedback}`; 

            saveTestResult(blinkCount, feedback, indiceLumina, blinkScore, luminosityScore); 
            
            scoreVisual.classList.remove("hidden");

            let barText = "";
            let barColor = "";
            let emoji = "";

            if (indiceLumina >= 80) { 
                barText = "Radiant";
                barColor = "bg-blue-500"; 
                emoji = "‚ú®";
            } else if (indiceLumina >= 60) {
                barText = "Clear";
                barColor = "bg-green-500";
                emoji = "üòä";
            } else if (indiceLumina >= 40) {
                barText = "Tired";
                barColor = "bg-yellow-500";
                emoji = "üòü";
            } else {
                barText = "Strained";
                barColor = "bg-red-500";
                emoji = "üò©";
            }

            const width = Math.min((indiceLumina / 100) * 100, 100); 

            scoreBar.style.width = `${width}%`;
            scoreBar.textContent = barText;
            scoreBar.className = `h-6 text-sm font-bold text-white text-center leading-6 rounded ${barColor}`;
            scoreEmoji.textContent = emoji;

            if (indiceLumina >= 60) {
                badgeSuccess.classList.remove("hidden");
                setTimeout(() => badgeSuccess.classList.remove("opacity-0"), 10);
                setTimeout(() => {
                    badgeSuccess.classList.add("hidden", "opacity-0");
                }, 6000); 
            }

            if (indiceLumina < 60) {
                relaxLink.classList.remove("hidden");
            } else {
                relaxLink.classList.add("hidden"); 
            }
        }

        // Stop/Continue Button Logic
        function toggleMonitoringPause() {
            if (monitoringPaused) {
                monitoringPaused = false;
                stopContinueBtn.textContent = "Stop Monitoring";
                statusMessage.textContent = "Monitoring in progress...";
                backgroundMusic.play(); // Resume background music
            } else {
                monitoringPaused = true;
                stopContinueBtn.textContent = "Continue Monitoring";
                statusMessage.textContent = "Monitoring paused. Click 'Continue Monitoring' to resume.";
                backgroundMusic.pause(); // Pause background music
            }
        }

        restartBtn.addEventListener("click", () => {
            monitoringActive = false; 
            monitoringPaused = false; 
            faceLostCounter = 0; 
            testResult.classList.add("hidden");
            restartBtn.classList.add("hidden");
            stopContinueBtn.classList.add("hidden"); // Hide on restart
            relaxLink.classList.add("hidden"); 
            badgeSuccess.classList.add("hidden", "opacity-0"); 
            scoreVisual.classList.add("hidden"); 
            statusMessage.textContent = "Awaiting camera initialization..."; 
            liveFeedback.textContent = ""; 
            blinkCount = 0; // Reset blink count
            isBlinking = false;
            framesBelowThreshold = 0;
            framesAboveThreshold = 0;
            testUI.classList.add("hidden");
            
            // Show duration selection and start button again
            startCameraBtn.classList.remove("hidden");
            durationSelectionContainer.classList.remove("hidden");

            // Stop previous camera stream if active
            if (rawVideoFeed.srcObject) {
                const tracks = rawVideoFeed.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                rawVideoFeed.srcObject = null;
            }

            // Re-attach the initial listener for camera initialization
            startCameraBtn.addEventListener('click', initialCameraClick); // Re-attach the named listener
            startCameraBtn.textContent = "Start Camera"; // Reset button text
        });

        // =====================================================================================
        // PERSISTENCE: History & Export - Logic removed from here, managed in dashboard.html
        // =====================================================================================
        // saveTestResult is now a standalone function needed by endMonitoring
        function saveTestResult(blinks, feedback, indiceLumina, blinkScore, luminosityScore) {
            const entry = {
                date: new Date().toLocaleString(),
                blinks,
                feedback,
                indiceLumina,
                blinkScore, 
                luminosityScore 
            };
            const history = JSON.parse(localStorage.getItem("vh_history") || "[]");
            history.push(entry);
            localStorage.setItem("vh_history", JSON.stringify(history));
            localStorage.setItem("liye_last_test", JSON.stringify(entry)); 
        }

        // =====================================================================================
        // REMINDERS Module - All logic removed from here (moved to central settings/background service later)
        // =====================================================================================


        // =====================================================================================
        // CORE: MediaPipe Integration (FaceMesh, Camera Utility, onResults)
        // =====================================================================================
        // Initialize FaceMesh outside the function, as it's a one-time setup
        const faceMesh = new FaceMesh({ 
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true, 
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(onResults);

        // This function obtains the camera stream and initializes MediaPipe's Camera utility.
        async function initCameraAndMediaPipeStream() { 
            console.log("DEBUG: initCameraAndMediaPipeStream called."); 
            startCameraBtn.classList.add("hidden"); 
            durationSelectionContainer.classList.add("hidden"); 
            statusMessage.textContent = "Initializing camera...";

            try {
                console.log("DEBUG: Attempting camera access (getUserMedia)."); 
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                console.log("DEBUG: Camera stream obtained."); 
                
                rawVideoFeed.srcObject = stream; 
                await rawVideoFeed.play(); 
                console.log("‚úÖ Camera started. Video stream visible in raw_video_feed.");
                statusMessage.textContent = "Camera active. LiYE is observing you..."; 
                
                const camera = new Camera({ 
                    videoElement: rawVideoFeed, 
                    onFrame: async () => {
                        await new Promise(requestAnimationFrame); 
                        await faceMesh.send({ image: rawVideoFeed }); 
                    },
                    width: 640,
                    height: 480
                });
                camera.start(); 
                console.log("‚úÖ MediaPipe Camera utility started processing.");

                // Now the button changes its role from "start camera" to "start monitoring"
                startCameraBtn.textContent = "Start Monitoring"; 
                startCameraBtn.classList.remove("hidden"); 
                durationSelectionContainer.classList.remove("hidden"); 
                statusMessage.textContent = "Camera ready. Click 'Start Monitoring'."; 
                
                // Remove the old listener and attach a new one for the second click
                startCameraBtn.removeEventListener('click', initialCameraClick); 
                startCameraBtn.addEventListener('click', startMonitoringClick); 

            } catch (err) {
                console.error("‚ùå Error accessing camera (catch block):", err); 
                statusMessage.textContent = `Error: Camera could not start. ${err.name}: ${err.message}. Check permissions or other apps using camera.`;
                startCameraBtn.classList.remove("hidden"); 
                durationSelectionContainer.classList.remove("hidden"); 
            }
            console.log("DEBUG: initCameraAndMediaPipeStream finished execution."); 
        }

        // Named function for the initial camera click event listener
        function initialCameraClick() {
            initCameraAndMediaPipeStream();
        }

        // Named function for the second click event listener (to start monitoring)
        function startMonitoringClick() {
            startMonitoring();
            // Remove this listener as well after it's served its purpose for this session
            startCameraBtn.removeEventListener('click', startMonitoringClick); 
        }

        // This function handles MediaPipe's drawing on the canvas and result processing.
        function onResults(results) {
            // console.log("DEBUG: onResults called. results.image:", results.image); 

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            // Draw MediaPipe's processed image (which includes the original feed + landmarks) onto the canvas.
            if (results.image) { 
                 canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height); 
                //  console.log("DEBUG: results.image drawn to canvas."); 
            } else {
                 console.warn("WARNING: results.image is not valid, cannot draw to canvas.");
            }
           

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                window.lastProcessedLandmarks = landmarks; 
                faceLostCounter = 0; 

                // Logic for blink detection and live feedback during monitoring
                // Only process if monitoring is active AND not paused
                if (monitoringActive && !monitoringPaused) { 
                    const earLeft = calculateEyeVerticalDistance(landmarks[LEFT_EYE_TOP], landmarks[LEFT_EYE_BOTTOM]);
                    const earRight = calculateEyeVerticalDistance(landmarks[RIGHT_EYE_TOP], landmarks[RIGHT_EYE_BOTTOM]);
                    const ear = Math.min(earLeft, earRight);

                    if (ear < EAR_THRESHOLD) {
                        framesBelowThreshold++;
                        framesAboveThreshold = 0;
                    } else {
                        framesAboveThreshold++;
                        framesBelowThreshold = 0;
                    }

                    if (framesBelowThreshold >= BLINK_HOLD_FRAMES && !isBlinking) {
                        blinkCount++;
                        isBlinking = true;
                    }

                    if (framesAboveThreshold >= BLINK_RESET_FRAMES && isBlinking) {
                        isBlinking = false;
                    }

                    const currentLuminosityScore = calculateLuminosityScore(canvasCtx, landmarks, canvasElement.width, canvasElement.height);
                    liveFeedback.textContent = `Blinks: ${blinkCount}, Luminosity: ${currentLuminosityScore}`;

                    // Draw landmarks ON TOP of the video feed on the canvas
                    canvasCtx.beginPath();
                    canvasCtx.arc(landmarks[LEFT_EYE_TOP].x * canvasElement.width, landmarks[LEFT_EYE_TOP].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.arc(landmarks[LEFT_EYE_BOTTOM].x * canvasElement.width, landmarks[LEFT_EYE_BOTTOM].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = '#FF4136';
                    canvasCtx.fill();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.moveTo(landmarks[LEFT_EYE_TOP].x * canvasElement.width, landmarks[LEFT_EYE_TOP].y * canvasElement.height);
                    canvasCtx.lineTo(landmarks[LEFT_EYE_BOTTOM].x * canvasElement.width, landmarks[LEFT_EYE_BOTTOM].y * canvasElement.height);
                    canvasCtx.strokeStyle = '#0074D9';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.arc(landmarks[RIGHT_EYE_TOP].x * canvasElement.width, landmarks[RIGHT_EYE_TOP].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.arc(landmarks[RIGHT_EYE_BOTTOM].x * canvasElement.width, landmarks[RIGHT_EYE_BOTTOM].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = '#FF4136';
                    canvasCtx.fill();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.moveTo(landmarks[RIGHT_EYE_TOP].x * canvasElement.width, landmarks[RIGHT_EYE_TOP].y * canvasElement.height);
                    canvasCtx.lineTo(landmarks[RIGHT_EYE_BOTTOM].x * canvasElement.width, landmarks[RIGHT_EYE_BOTTOM].y * canvasElement.height);
                    canvasCtx.strokeStyle = '#0074D9';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.arc(landmarks[LEFT_IRIS_CENTER].x * canvasElement.width, landmarks[LEFT_IRIS_CENTER].y * canvasElement.height, 2, 0, 2 * Math.PI);
                    canvasCtx.arc(landmarks[RIGHT_IRIS_CENTER].x * canvasElement.width, landmarks[RIGHT_IRIS_CENTER].y * canvasElement.height, 2, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = '#FF851B'; 
                    canvasCtx.fill();
                    canvasCtx.closePath();
                }

            } else { 
                window.lastProcessedLandmarks = null; 
                
                if (monitoringActive) { // Changed from testStarted
                    faceLostCounter++;
                    if (faceLostCounter >= MAX_FACE_LOST_FRAMES) { 
                        clearInterval(monitoringTimer); // Renamed timer
                        backgroundMusic.pause();
                        statusMessage.textContent = "Monitoring interrupted. Reposition your face to resume."; 
                        monitoringActive = false; // Set monitoring to false
                        restartBtn.classList.remove("hidden");
                        stopContinueBtn.classList.add("hidden"); // Hide stop/continue
                        liveFeedback.textContent = ""; 
                    } else {
                        const secondsRemaining = Math.floor((MAX_FACE_LOST_FRAMES - faceLostCounter) / 30); 
                        statusMessage.textContent = `Face lost! Reposition to continue monitoring. (${secondsRemaining}s)`; 
                    }
                } else { 
                    statusMessage.textContent = "No face detected. Position your face in front of the camera.";
                    // stableFaceCounter is not used in this workflow.
                    faceLostCounter = 0; 
                }
            }

            canvasCtx.restore();
        }

        // =====================================================================================
        // Initializations & Event Listeners (on DOMContentLoaded)
        // =====================================================================================

        document.addEventListener("DOMContentLoaded", () => {
            // Privacy Warning & Instructions Visibility
            const privacyWarningShown = localStorage.getItem('liye_privacy_warning_hidden');
            if (privacyWarningShown === 'true') {
                privacyWarning.classList.add('hidden');
                hidePrivacyWarningCheckbox.checked = true;
            }
            hidePrivacyWarningCheckbox.addEventListener('change', () => {
                localStorage.setItem('liye_privacy_warning_hidden', hidePrivacyWarningCheckbox.checked);
                privacyWarning.classList.toggle('hidden', hidePrivacyWarningCheckbox.checked);
            });

            const instructionsShown = localStorage.getItem('liye_instructions_hidden');
            if (instructionsShown === 'true') {
                instructionsDiv.classList.add('hidden');
                hideInstructionsCheckbox.checked = true;
            }
            hideInstructionsCheckbox.addEventListener('change', () => {
                localStorage.setItem('liye_instructions_hidden', hideInstructionsCheckbox.checked);
                instructionsDiv.classList.toggle('hidden', hideInstructionsCheckbox.checked);
            });

            // Offline Status
            if (!navigator.onLine) {
                offlineStatus.classList.remove("hidden");
            }
            window.addEventListener('online', () => offlineStatus.classList.add("hidden"));
            window.addEventListener('offline', () => offlineStatus.classList.remove("hidden"));

            // Reminders logic removed from vision-test.html, as discussed.

            // Initial setup for the button click sequence
            startCameraBtn.addEventListener('click', initialCameraClick); 
            
            // Listener for Stop/Continue button
            stopContinueBtn.addEventListener('click', toggleMonitoringPause);
        });
    </script>

</body>
</html>
