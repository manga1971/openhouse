<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8" />
    <title>Test Clipit ‚Äì LiYE Vision</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <link rel="icon" href="favicon.ico" />
    <style>
        body {
            font-family: sans-serif; /* Tailwind default is sans-serif, align with index.html */
        }
        /* Stiluri pentru elementele video »ôi canvas, ambele vizibile pentru debugging */
        #raw_video_feed { /* Renamed from input_video */
            display: block; /* Va fi vizibil */
            border: 2px solid red; /* Chenarul ro»ôu */
            width: 640px; /* Aliniat cu canvas */
            height: 480px; /* Aliniat cu canvas */
            margin: auto;
            margin-bottom: 10px; /* Spa»õiu √Æntre ele */
        }
        #output_canvas {
            border: 2px solid #3b82f6; /* Blue border for LiYE theme */
            display: block; /* Va fi vizibil */
            margin: auto;
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        /* Stil pentru checkbox-ul personalizat, dacƒÉ e nevoie */
        .checkbox-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
        }
        .checkbox-container input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #3b82f6; /* Culoarea de accent Tailwind blue-500 */
        }
        /* Stil pentru badge de succes (pentru a aplica opacity transition) */
        #badge-success.hidden {
            display: none !important;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 text-center">

    <h1 class="text-3xl font-extrabold mb-4 text-blue-800">Test Clipit üëÅÔ∏è LiYE Vision</h1>
    
    <div id="privacy-warning" class="mb-4 text-gray-700 bg-red-100 border-l-4 border-red-500 p-4" role="alert">
        <p class="font-bold">**Confiden»õialitate:**</p>
        <p>Imaginile captate de camerƒÉ sunt procesate **exclusiv pe dispozitivul dumneavoastrƒÉ** »ôi nu sunt stocate, transmise sau accesate de cƒÉtre dezvoltator.</p>
        <div class="checkbox-container">
            <input type="checkbox" id="hide-privacy-warning" class="form-checkbox">
            <label for="hide-privacy-warning">Nu mai afi»ôa acest mesaj</label>
        </div>
    </div>

    <div id="instructions" class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4" role="alert">
        <p class="font-bold">Instruc»õiuni:</p>
        <p>Pozi»õiona»õi-vƒÉ fa»õa √Æn cadru »ôi privi»õi direct la camerƒÉ. LiYE vƒÉ va observa »ôi vƒÉ va oferi feedback.</p>
        <div class="checkbox-container">
            <input type="checkbox" id="hide-instructions" class="form-checkbox">
            <label for="hide-instructions">Nu mai afi»ôa aceste instruc»õiuni</label>
        </div>
    </div>

    <video id="raw_video_feed" autoplay muted playsinline></video> 
    <canvas id="output_canvas" width="640" height="480"></canvas>

    <p id="status-message" class="mt-2 text-md text-gray-600">A»ôtept ini»õializarea camerei...</p>
    <p id="live-feedback" class="text-sm mt-2 text-gray-500"></p> 
    <p id="offline-status" class="text-sm text-yellow-600 mt-2 hidden">Mod offline activ. Unele func»õionalitƒÉ»õi pot fi limitate.</p> 

    <div class="mt-4 mb-4 flex justify-center items-center gap-4" id="duration-selection-container">
        <span class="text-gray-700 font-medium">DuratƒÉ monitorizare:</span>
        <label class="inline-flex items-center">
            <input type="radio" name="monitorDuration" value="60" checked class="form-radio text-blue-600">
            <span class="ml-2 text-gray-700">60 secunde</span>
        </label>
        <label class="inline-flex items-center">
            <input type="radio" name="monitorDuration" value="120" class="form-radio text-blue-600">
            <span class="ml-2 text-gray-700">120 secunde</span>
        </label>
    </div>

    <button id="start-camera-btn" class="px-6 py-3 bg-blue-600 text-white rounded hover:bg-blue-700 transition mt-4">
        Porne»ôte Camera
    </button>

    <div id="test-ui" class="mt-6 hidden">
        <div class="text-lg font-medium text-gray-700 mb-2">Timp rƒÉmas: <span id="time-left">60</span> secunde</div>
        <div class="w-full h-4 bg-gray-300 rounded">
            <div id="progress-bar" class="h-4 bg-blue-500 rounded" style="width: 0%; transition: width 1s linear;"></div>
        </div>
    </div>

    <p id="test-result" class="mt-6 text-xl font-bold text-gray-800 hidden"></p>

    <div id="badge-success" class="hidden opacity-0 transition-opacity duration-500 mt-4 text-green-700 font-semibold">
        üü¢ FelicitƒÉri! Privirea ta este √Æn formƒÉ excelentƒÉ!
    </div>

    <div id="score-visual" class="mt-4 hidden">
        <div class="w-full h-6 bg-gray-200 rounded">
            <div id="score-bar" class="h-6 text-sm font-bold text-white text-center leading-6 rounded"></div>
        </div>
        <div id="score-emoji" class="text-4xl mt-2"></div>
    </div>

    <audio id="background-music" loop preload="auto">
        <source src="audio/calm-background-117564.mp3" type="audio/mpeg">
    </audio>
    <audio id="start-sound" preload="auto">
        <source src="audio/short-success-sound-glitch-40993.mp3" type="audio/mpeg">
    </audio>
    <audio id="end-sound" preload="auto">
        <source src="audio/completion-sound-148813.mp3" type="audio/mpeg">
    </audio>

    <button id="restart-btn" class="mt-4 hidden px-4 py-2 bg-blue-600 text-white font-semibold rounded hover:bg-blue-700 transition">
        Re√Æncepe Testul
    </button>
    <a href="exercitii.html" id="relax-link" class="mt-4 text-blue-600 underline hidden">üîÅ RelaxeazƒÉ-»õi ochii acum</a> 
    
    <a href="index.html" class="block mt-6 text-sm text-gray-500 hover:text-blue-600 underline">‚Üê √énapoi la Pagina PrincipalƒÉ</a>

    <script>
        // =====================================================================================
        // UI Elements (Declara»õii globale)
        // =====================================================================================
        const rawVideoFeed = document.getElementById("raw_video_feed"); 
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const statusMessage = document.getElementById("status-message");
        const liveFeedback = document.getElementById("live-feedback"); 
        const offlineStatus = document.getElementById("offline-status"); 

        const startCameraBtn = document.getElementById("start-camera-btn"); 
        const durationSelectionContainer = document.getElementById("duration-selection-container"); 
        const radioButtonsMonitorDuration = document.querySelectorAll('input[name="monitorDuration"]'); 

        const privacyWarning = document.getElementById("privacy-warning"); 
        const hidePrivacyWarningCheckbox = document.getElementById("hide-privacy-warning"); 
        const instructionsDiv = document.getElementById("instructions"); 
        const hideInstructionsCheckbox = document.getElementById("hide-instructions"); 

        const timeLeftEl = document.getElementById("time-left");
        const progressBar = document.getElementById("progress-bar");
        const testUI = document.getElementById("test-ui");
        const testResult = document.getElementById("test-result");
        const restartBtn = document.getElementById("restart-btn");
        const relaxLink = document.getElementById("relax-link"); 
        const backgroundMusic = document.getElementById("background-music");
        const startSound = document.getElementById("start-sound"); 
        const endSound = document.getElementById("end-sound");     
        const badgeSuccess = document.getElementById("badge-success"); 

        const scoreVisual = document.getElementById("score-visual");
        const scoreBar = document.getElementById("score-bar");
        const scoreEmoji = document.getElementById("score-emoji");


        // MediaPipe Landmark Indices
        const LEFT_EYE_TOP = 159;
        const LEFT_EYE_BOTTOM = 145;
        const RIGHT_EYE_TOP = 386;
        const RIGHT_EYE_BOTTOM = 374;
        const LEFT_IRIS_CENTER = 468;
        const RIGHT_IRIS_CENTER = 473;

        // Configuration
        const EAR_THRESHOLD = 0.015; 
        const BLINK_HOLD_FRAMES = 2; 
        const BLINK_RESET_FRAMES = 5; 
        const STABLE_THRESHOLD = 30; // Not used in current workflow, but kept for reference
        const MAX_FACE_LOST_FRAMES = 150; 

        // Global State Variables
        let blinkCount = 0;
        let isBlinking = false;
        let framesBelowThreshold = 0;
        let framesAboveThreshold = 0;
        let testStarted = false; // Indicates if monitoring is active
        let testTimer;
        let testDuration = 60; // Default, will be updated by radio buttons
        let currentSecond = 0;
        let faceLostCounter = 0; 
        window.lastProcessedLandmarks = null; 

        // =====================================================================================
        // CORE: Indice Lumina Calculation Functions
        // =====================================================================================

        function calculateEyeVerticalDistance(top, bottom) {
            return Math.hypot(top.y - bottom.y);
        }

        function calculateBlinkScore(blinksPerMinute) {
            const OPTIMAL_MIN = 12;
            const OPTIMAL_MAX = 22;
            const EXTREME_LOW = 5;
            const EXTREME_HIGH = 30;

            if (blinksPerMinute >= OPTIMAL_MIN && blinksPerMinute <= OPTIMAL_MAX) {
                return 100; 
            } else if (blinksPerMinute < EXTREME_LOW || blinksPerMinute > EXTREME_HIGH) {
                return 20; 
            } else if (blinksPerMinute >= EXTREME_LOW && blinksPerMinute < OPTIMAL_MIN) {
                return Math.round(20 + (blinksPerMinute - EXTREME_LOW) / (OPTIMAL_MIN - EXTREME_LOW) * 80);
            } else if (blinksPerMinute > OPTIMAL_MAX && blinksPerMinute <= EXTREME_HIGH) {
                return Math.round(20 + (EXTREME_HIGH - blinksPerMinute) / (EXTREME_HIGH - OPTIMAL_MAX) * 80);
            }
            return 0; 
        }

        function calculateLuminosityScore(canvasCtx, landmarks, canvasWidth, canvasHeight) {
            if (!landmarks) return 0;

            let totalBrightness = 0;
            let pixelCount = 0;

            const irisLandmarkIndices = [LEFT_IRIS_CENTER, RIGHT_IRIS_CENTER];

            irisLandmarkIndices.forEach(index => {
                const irisCenter = landmarks[index];
                if (!irisCenter) return;

                const irisRadius = Math.round(canvasWidth * 0.015); 
                const x = Math.round(irisCenter.x * canvasWidth);
                const y = Math.round(irisCenter.y * canvasHeight);

                try {
                    const startX = Math.max(0, x - irisRadius);
                    const startY = Math.max(0, y - irisRadius);
                    const width = Math.min(irisRadius * 2, canvasWidth - startX);
                    const height = Math.min(irisRadius * 2, canvasHeight - startY);

                    if (width <= 0 || height <= 0) return; 

                    const imageData = canvasCtx.getImageData(
                        startX,
                        startY,
                        width,
                        height
                    );

                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const r = imageData.data[i];
                        const g = imageData.data[i + 1];
                        const b = imageData.data[i + 2];
                        const brightness = (r + g + b) / 3; 
                        totalBrightness += brightness;
                        pixelCount++;
                    }
                } catch (e) {
                    console.warn("Eroare la getImageData pentru iris:", e);
                }
            });

            if (pixelCount === 0) return 0;

            const averageBrightness = totalBrightness / pixelCount;

            const minBrightness = 70;  
            const maxBrightness = 220; 

            let normalizedScore = (averageBrightness - minBrightness) / (maxBrightness - minBrightness) * 100;
            normalizedScore = Math.min(100, Math.max(0, normalizedScore)); 

            return Math.round(normalizedScore);
        }

        function calculateIndiceLumina(blinkScore, luminosityScore, w_blink = 0.6, w_lum = 0.4) {
            return Math.round(w_blink * blinkScore + w_lum * luminosityScore);
        }

        function interpretIndiceLumina(score) {
            if (score >= 80) return "‚ú® Privirea ta este strƒÉlucitoare! E momentul perfect sƒÉ continui activitƒÉ»õile creative.";
            if (score >= 60) return "üòä Privirea ta este clarƒÉ. O scurtƒÉ pauzƒÉ »õi-ar pƒÉstra concentrarea.";
            if (score >= 40) return "üòü Privirea ta pare obositƒÉ. RecomandƒÉm 3 minute de exerci»õii vizuale.";
            return "üò© Privirea ta este tensionatƒÉ. Opre»ôte-te 5 minute, respirƒÉ ad√¢nc »ôi prive»ôte √Æn depƒÉrtare.";
        }

        // =====================================================================================
        // CORE: Test Control Functions (now "Monitoring")
        // =====================================================================================

        function startMonitoring() { // Renamed from startTest
            testStarted = true; // Use testStarted as monitoringStarted
            blinkCount = 0;
            currentSecond = 0;
            testDuration = parseInt(document.querySelector('input[name="monitorDuration"]:checked').value); // Get selected duration
            timeLeftEl.textContent = testDuration;
            
            // Hide duration selection and start button
            startCameraBtn.classList.add("hidden");
            durationSelectionContainer.classList.add("hidden");

            testUI.classList.remove("hidden");
            testResult.classList.add("hidden");
            restartBtn.classList.add("hidden");
            relaxLink.classList.add("hidden"); 
            badgeSuccess.classList.add("hidden", "opacity-0"); 
            scoreVisual.classList.add("hidden"); 
            statusMessage.textContent = "Monitorizare √Æn desfƒÉ»ôurare...";
            backgroundMusic.currentTime = 0;
            backgroundMusic.play();
            startSound.currentTime = 0; // Reset and play start sound
            startSound.play().catch(e => console.log("Eroare redare sunet start:", e));
            liveFeedback.textContent = ""; 

            testTimer = setInterval(() => {
                currentSecond++;
                timeLeftEl.textContent = testDuration - currentSecond;
                const progress = (currentSecond / testDuration) * 100;
                progressBar.style.width = `${progress}%`;

                if (currentSecond >= testDuration) {
                    endMonitoring(); // Renamed from endTest
                }
            }, 1000);
        }

        function endMonitoring() // Renamed from endTest
        {
            clearInterval(testTimer);
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0; 
            endSound.currentTime = 0; // Reset and play end sound
            endSound.play().catch(e => console.log("Eroare redare sunet final:", e));
            
            testUI.classList.add("hidden");
            testResult.classList.remove("hidden");
            restartBtn.classList.remove("hidden");
            liveFeedback.textContent = ""; 

            const blinksPerMinute = (blinkCount / testDuration) * 60;

            const blinkScore = calculateBlinkScore(blinksPerMinute);

            let luminosityScore = 0;
            if (window.lastProcessedLandmarks) {
                luminosityScore = calculateLuminosityScore(canvasCtx, window.lastProcessedLandmarks, canvasElement.width, canvasElement.height);
            } else {
                console.warn("Nu s-au putut calcula LuminosityScore: landmark-uri lipsƒÉ.");
            }

            const indiceLumina = calculateIndiceLumina(blinkScore, luminosityScore);
            const feedback = interpretIndiceLumina(indiceLumina);

            testResult.textContent = `Clipituri: ${blinksPerMinute.toFixed(1)}/min ‚Äì Indice Lumina: ${indiceLumina} ‚Äì ${feedback}`; // Adjusted display

            saveTestResult(blinkCount, feedback, indiceLumina, blinkScore, luminosityScore); 
            
            scoreVisual.classList.remove("hidden");

            let barText = "";
            let barColor = "";
            let emoji = "";

            if (indiceLumina >= 80) { 
                barText = "StrƒÉlucitoare";
                barColor = "bg-blue-500"; 
                emoji = "‚ú®";
            } else if (indiceLumina >= 60) {
                barText = "Claritate";
                barColor = "bg-green-500";
                emoji = "üòä";
            } else if (indiceLumina >= 40) {
                barText = "ObositƒÉ";
                barColor = "bg-yellow-500";
                emoji = "üòü";
            } else {
                barText = "TensionatƒÉ";
                barColor = "bg-red-500";
                emoji = "üò©";
            }

            const width = Math.min((indiceLumina / 100) * 100, 100); 

            scoreBar.style.width = `${width}%`;
            scoreBar.textContent = barText;
            scoreBar.className = `h-6 text-sm font-bold text-white text-center leading-6 rounded ${barColor}`;
            scoreEmoji.textContent = emoji;

            if (indiceLumina >= 60) {
                badgeSuccess.classList.remove("hidden");
                setTimeout(() => badgeSuccess.classList.remove("opacity-0"), 10);
                setTimeout(() => {
                    badgeSuccess.classList.add("hidden", "opacity-0");
                }, 6000); 
            }

            if (indiceLumina < 60) {
                relaxLink.classList.remove("hidden");
            } else {
                relaxLink.classList.add("hidden"); 
            }

            // resetReminderTimer(); // Memento-urile sunt eliminate
        }

        restartBtn.addEventListener("click", () => {
            testStarted = false; // Set monitoring to false
            // stableFaceCounter = 0; // This variable is not used in the current version
            faceLostCounter = 0; 
            testResult.classList.add("hidden");
            restartBtn.classList.add("hidden");
            relaxLink.classList.add("hidden"); 
            badgeSuccess.classList.add("hidden", "opacity-0"); 
            scoreVisual.classList.add("hidden"); 
            // blinkDisplay.textContent = "Clipituri: 0"; // Removed blinkDisplay element
            statusMessage.textContent = "A»ôtept ini»õializarea camerei..."; 
            liveFeedback.textContent = ""; 
            isBlinking = false;
            framesBelowThreshold = 0;
            framesAboveThreshold = 0;
            testUI.classList.add("hidden");
            
            // Show duration selection and start button again
            startCameraBtn.classList.remove("hidden");
            durationSelectionContainer.classList.remove("hidden");

            // Stop previous camera stream if active
            if (rawVideoFeed.srcObject) {
                const tracks = rawVideoFeed.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                rawVideoFeed.srcObject = null;
            }

            // Re-attach the initial listener for camera initialization
            startCameraBtn.addEventListener('click', initialCameraClick); // Re-attach the named listener
            startCameraBtn.textContent = "Porne»ôte Camera"; // Reset button text
        });

        // =====================================================================================
        // PERSISTENCE: History & Export - Logic removed from here, managed in dashboard.html
        // =====================================================================================
        // saveTestResult and loadHistory are now standalone functions needed by endMonitoring
        // The UI elements for history section, clear/export buttons are removed from vision-test.html

        function saveTestResult(blinks, feedback, indiceLumina, blinkScore, luminosityScore) {
            const entry = {
                date: new Date().toLocaleString(),
                blinks,
                feedback,
                indiceLumina,
                blinkScore, 
                luminosityScore 
            };
            const history = JSON.parse(localStorage.getItem("vh_history") || "[]");
            history.push(entry);
            localStorage.setItem("vh_history", JSON.stringify(history));
            localStorage.setItem("liye_last_test", JSON.stringify(entry)); 
        }

        // =====================================================================================
        // REMINDERS Module - All logic removed from here (moved to central settings/background service later)
        // =====================================================================================


        // =====================================================================================
        // CORE: MediaPipe Integration (FaceMesh, Camera Utility, onResults)
        // =====================================================================================
        // Initialize FaceMesh outside the function, as it's a one-time setup
        const faceMesh = new FaceMesh({ 
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true, 
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(onResults);

        // This function obtains the camera stream and initializes MediaPipe's Camera utility.
        async function initCameraAndMediaPipeStream() { // Renamed for clarity
            console.log("DEBUG: initCameraAndMediaPipeStream a fost apelatƒÉ."); 
            // Hide the start button and duration selection temporarily
            startCameraBtn.classList.add("hidden"); 
            durationSelectionContainer.classList.add("hidden"); 
            statusMessage.textContent = "Se ini»õializeazƒÉ camera...";

            try {
                console.log("DEBUG: √éncercƒÉ accesul la camera (getUserMedia)."); 
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                console.log("DEBUG: Fluxul camerei a fost ob»õinut."); 
                
                rawVideoFeed.srcObject = stream; 
                await rawVideoFeed.play(); 
                console.log("‚úÖ Camera a pornit. Flux video vizibil √Æn raw_video_feed.");
                statusMessage.textContent = "Camera activƒÉ. LiYE te observƒÉ..."; 
                
                // Now that raw_video_feed is playing, initialize and start MediaPipe's Camera utility.
                const camera = new Camera({ 
                    videoElement: rawVideoFeed, 
                    onFrame: async () => {
                        await new Promise(requestAnimationFrame); // ADDED THIS LINE
                        await faceMesh.send({ image: rawVideoFeed }); 
                    },
                    width: 640,
                    height: 480
                });
                camera.start(); 
                console.log("‚úÖ MediaPipe Camera utility a pornit procesarea.");

                // Now the button changes its role from "start camera" to "start monitoring"
                startCameraBtn.textContent = "√éncepe Monitorizarea"; 
                startCameraBtn.classList.remove("hidden"); // Make button visible again (for the second click)
                durationSelectionContainer.classList.remove("hidden"); // Show duration selection again
                statusMessage.textContent = "Camera gata. Click '√éncepe Monitorizarea'."; // Status for user
                
                // Remove the old listener and attach a new one for the second click
                // This is crucial for the double-click behavior
                startCameraBtn.removeEventListener('click', initialCameraClick); // Remove the initial listener
                startCameraBtn.addEventListener('click', startMonitoringClick); // Add the new listener

            } catch (err) {
                console.error("‚ùå Eroare la accesul camerei (catch block):", err); 
                statusMessage.textContent = `Eroare: Camera nu a putut porni. ${err.name}: ${err.message}. Verifica»õi permisiunile sau alte aplica»õii care folosesc camera.`;
                startCameraBtn.classList.remove("hidden"); 
                durationSelectionContainer.classList.remove("hidden"); 
            }
            console.log("DEBUG: initCameraAndMediaPipeStream a terminat execu»õia."); 
        }

        // Named function for the initial camera click event listener
        function initialCameraClick() {
            initCameraAndMediaPipeStream();
        }

        // Named function for the second click event listener (to start monitoring)
        function startMonitoringClick() {
            startMonitoring();
            // Remove this listener as well after it's served its purpose for this session
            startCameraBtn.removeEventListener('click', startMonitoringClick); 
        }

        // This function handles MediaPipe's drawing on the canvas and result processing.
        function onResults(results) {
            // console.log("DEBUG: onResults called. results.image:", results.image); 

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            // Draw MediaPipe's processed image (which includes the original feed + landmarks) onto the canvas.
            if (results.image) { 
                 canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height); 
                //  console.log("DEBUG: results.image drawn to canvas."); 
            } else {
                 console.warn("WARNING: results.image is not valid, cannot draw to canvas.");
            }
           

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                window.lastProcessedLandmarks = landmarks; 
                faceLostCounter = 0; 

                // Logic for blink detection and live feedback during monitoring
                if (testStarted) { 
                    const earLeft = calculateEyeVerticalDistance(landmarks[LEFT_EYE_TOP], landmarks[LEFT_EYE_BOTTOM]);
                    const earRight = calculateEyeVerticalDistance(landmarks[RIGHT_EYE_TOP], landmarks[RIGHT_EYE_BOTTOM]);
                    const ear = Math.min(earLeft, earRight);

                    if (ear < EAR_THRESHOLD) {
                        framesBelowThreshold++;
                        framesAboveThreshold = 0;
                    } else {
                        framesAboveThreshold++;
                        framesBelowThreshold = 0;
                    }

                    if (framesBelowThreshold >= BLINK_HOLD_FRAMES && !isBlinking) {
                        blinkCount++;
                        isBlinking = true;
                    }

                    if (framesAboveThreshold >= BLINK_RESET_FRAMES && isBlinking) {
                        isBlinking = false;
                    }

                    const currentLuminosityScore = calculateLuminosityScore(canvasCtx, landmarks, canvasElement.width, canvasElement.height);
                    liveFeedback.textContent = `Clipiri: ${blinkCount}, Luminozitate: ${currentLuminosityScore}`;

                    // Draw landmarks ON TOP of the video feed on the canvas
                    canvasCtx.beginPath();
                    canvasCtx.arc(landmarks[LEFT_EYE_TOP].x * canvasElement.width, landmarks[LEFT_EYE_TOP].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.arc(landmarks[LEFT_EYE_BOTTOM].x * canvasElement.width, landmarks[LEFT_EYE_BOTTOM].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = '#FF4136';
                    canvasCtx.fill();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.moveTo(landmarks[LEFT_EYE_TOP].x * canvasElement.width, landmarks[LEFT_EYE_TOP].y * canvasElement.height);
                    canvasCtx.lineTo(landmarks[LEFT_EYE_BOTTOM].x * canvasElement.width, landmarks[LEFT_EYE_BOTTOM].y * canvasElement.height);
                    canvasCtx.strokeStyle = '#0074D9';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.arc(landmarks[RIGHT_EYE_TOP].x * canvasElement.width, landmarks[RIGHT_EYE_TOP].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.arc(landmarks[RIGHT_EYE_BOTTOM].x * canvasElement.width, landmarks[RIGHT_EYE_BOTTOM].y * canvasElement.height, 3, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = '#FF4136';
                    canvasCtx.fill();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.moveTo(landmarks[RIGHT_EYE_TOP].x * canvasElement.width, landmarks[RIGHT_EYE_TOP].y * canvasElement.height);
                    canvasCtx.lineTo(landmarks[RIGHT_EYE_BOTTOM].x * canvasElement.width, landmarks[RIGHT_EYE_BOTTOM].y * canvasElement.height);
                    canvasCtx.strokeStyle = '#0074D9';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                    canvasCtx.closePath();

                    canvasCtx.beginPath();
                    canvasCtx.arc(landmarks[LEFT_IRIS_CENTER].x * canvasElement.width, landmarks[LEFT_IRIS_CENTER].y * canvasElement.height, 2, 0, 2 * Math.PI);
                    canvasCtx.arc(landmarks[RIGHT_IRIS_CENTER].x * canvasElement.width, landmarks[RIGHT_IRIS_CENTER].y * canvasElement.height, 2, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = '#FF851B'; 
                    canvasCtx.fill();
                    canvasCtx.closePath();
                }

            } else { 
                window.lastProcessedLandmarks = null; 
                
                if (testStarted) { 
                    faceLostCounter++;
                    if (faceLostCounter >= MAX_FACE_LOST_FRAMES) { 
                        clearInterval(testTimer);
                        backgroundMusic.pause();
                        statusMessage.textContent = "Monitorizare √ÆntreruptƒÉ. Repozi»õiona»õi fa»õa pentru reluare."; 
                        testStarted = false;
                        restartBtn.classList.remove("hidden");
                        liveFeedback.textContent = ""; 
                    } else {
                        const secondsRemaining = Math.floor((MAX_FACE_LOST_FRAMES - faceLostCounter) / 30); 
                        statusMessage.textContent = `Fa»õa pierdutƒÉ! Relua»õi pozi»õia pentru a continua monitorizarea. (${secondsRemaining}s)`; 
                    }
                } else { 
                    statusMessage.textContent = "Nicio fa»õƒÉ detectatƒÉ. Pozi»õiona»õi-vƒÉ √Æn fa»õa camerei.";
                    // stableFaceCounter = 0; // This variable is not used in the current version
                    faceLostCounter = 0; 
                }
            }

            canvasCtx.restore();
        }

        // =====================================================================================
        // Initializations & Event Listeners (on DOMContentLoaded)
        // =====================================================================================

        document.addEventListener("DOMContentLoaded", () => {
            // Privacy Warning & Instructions Visibility (New Logic)
            const privacyWarningShown = localStorage.getItem('liye_privacy_warning_hidden');
            if (privacyWarningShown === 'true') {
                privacyWarning.classList.add('hidden');
                hidePrivacyWarningCheckbox.checked = true;
            }
            hidePrivacyWarningCheckbox.addEventListener('change', () => {
                localStorage.setItem('liye_privacy_warning_hidden', hidePrivacyWarningCheckbox.checked);
                privacyWarning.classList.toggle('hidden', hidePrivacyWarningCheckbox.checked);
            });

            const instructionsShown = localStorage.getItem('liye_instructions_hidden');
            if (instructionsShown === 'true') {
                instructionsDiv.classList.add('hidden');
                hideInstructionsCheckbox.checked = true;
            }
            hideInstructionsCheckbox.addEventListener('change', () => {
                localStorage.setItem('liye_instructions_hidden', hideInstructionsCheckbox.checked);
                instructionsDiv.classList.toggle('hidden', hideInstructionsCheckbox.checked);
            });

            // Status offline
            if (!navigator.onLine) {
                offlineStatus.classList.remove("hidden");
            }
            window.addEventListener('online', () => offlineStatus.classList.add("hidden"));
            window.addEventListener('offline', () => offlineStatus.classList.remove("hidden"));

            // Initial camera stream setup (first click)
            startCameraBtn.addEventListener('click', initialCameraClick); // Attach the initial listener
        });
    </script>

</body>
</html>
